/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2012 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "CudaMeldKernelSources.h"

using namespace MeldPlugin;
using namespace std;

const string CudaMeldKernelSources::computeMeld = "/*\n"
"   Copyright 2015 by Justin MacCallum, Alberto Perez, Ken Dill\n"
"   All rights reserved\n"
"*/\n"
"// #include <stdio.h>\n"
"// __device__ float3 RealToFloat3(real4 v)\n"
"// {\n"
"//     return make_float3(v.x, v.y, v.z);\n"
"// }\n"
"\n"
"// __device__ real4 Float3ToVec3(float3 v)\n"
"// {\n"
"//     return real4(\n"
"//         v.x,\n"
"//         v.y,\n"
"//         v.z);\n"
"// }\n"
"\n"
"#define ELEM_SWAP(a,b) { int t=(a);(a)=(b);(b)=t; }\n"
"\n"
"__device__ float quick_select_float(const volatile float* energy, volatile int *index, int nelems, int select) {\n"
"    int low, high, middle, ll, hh;\n"
"\n"
"    low = 0;\n"
"    high = nelems - 1;\n"
"\n"
"    for (;;) {\n"
"        if (high <= low) { /* One element only */\n"
"            return energy[index[select]];\n"
"        }\n"
"\n"
"        if (high == low + 1) {  /* Two elements only */\n"
"            if (energy[index[low]] > energy[index[high]])\n"
"                ELEM_SWAP(index[low], index[high]);\n"
"            return energy[index[select]];\n"
"        }\n"
"\n"
"        /* Find median of low, middle and high items; swap into position low */\n"
"        middle = (low + high) / 2;\n"
"        if (energy[index[middle]] > energy[index[high]])    ELEM_SWAP(index[middle], index[high]);\n"
"        if (energy[index[low]]    > energy[index[high]])    ELEM_SWAP(index[low],    index[high]);\n"
"        if (energy[index[middle]] > energy[index[low]])     ELEM_SWAP(index[middle], index[low]);\n"
"\n"
"        /* Swap low item (now in position middle) into position (low+1) */\n"
"        ELEM_SWAP(index[middle], index[low+1]);\n"
"\n"
"        /* Nibble from each end towards middle, swapping items when stuck */\n"
"        ll = low + 1;\n"
"        hh = high;\n"
"        for (;;) {\n"
"            do ll++; while (energy[index[low]] > energy[index[ll]]);\n"
"            do hh--; while (energy[index[hh]]  > energy[index[low]]);\n"
"\n"
"            if (hh < ll)\n"
"                break;\n"
"\n"
"            ELEM_SWAP(index[ll], index[hh]);\n"
"        }\n"
"\n"
"        /* Swap middle item (in position low) back into correct position */\n"
"        ELEM_SWAP(index[low], index[hh]);\n"
"\n"
"        /* Re-set active partition */\n"
"        if (hh <= select)\n"
"            low = ll;\n"
"        if (hh >= select)\n"
"            high = hh - 1;\n"
"    }\n"
"}\n"
"#undef ELEM_SWAP\n"
"\n"
"\n"
"__device__ void computeTorsionAngle(const real4* __restrict__ posq, int atom_i, int atom_j, int atom_k, int atom_l,\n"
"        float3& r_ij, float3& r_kj, float3& r_kl, float3& m, float3& n,\n"
"        float& len_r_kj, float& len_m, float& len_n, float& phi) {\n"
"    // compute vectors\n"
"    r_ij = trimTo3(posq[atom_j] - posq[atom_i]);\n"
"    r_kj = trimTo3(posq[atom_j] - posq[atom_k]);\n"
"    r_kl = trimTo3(posq[atom_l] - posq[atom_k]);\n"
"\n"
"    // compute normal vectors\n"
"    m = cross(r_ij, r_kj);\n"
"    n = cross(r_kj, r_kl);\n"
"\n"
"    // compute lengths\n"
"    len_r_kj = sqrt(dot(r_kj, r_kj));\n"
"    len_m = sqrt(dot(m, m));\n"
"    len_n = sqrt(dot(n, n));\n"
"\n"
"    // compute angle phi\n"
"    float x = dot(m / len_m, n / len_n);\n"
"    float y = dot(cross(m / len_m, r_kj / len_r_kj), n / len_n);\n"
"    phi = atan2(y, x) * 180. / 3.141592654;\n"
"}\n"
"\n"
"\n"
"__device__ void computeTorsionForce(const float dEdPhi, const float3& r_ij, const float3& r_kj, const float3& r_kl,\n"
"        const float3& m, const float3& n, const float len_r_kj, const float len_m, const float len_n,\n"
"        float3& F_i, float3& F_j, float3& F_k, float3& F_l) {\n"
"    F_i = -180. / 3.141592654 * dEdPhi * len_r_kj * m / (len_m * len_m);\n"
"    F_l = 180. / 3.141592654 * dEdPhi * len_r_kj * n / (len_n * len_n);\n"
"    F_j = -F_i + dot(r_ij, r_kj) / (len_r_kj * len_r_kj) * F_i - dot(r_kl, r_kj) / (len_r_kj * len_r_kj) * F_l;\n"
"    F_k = -F_l - dot(r_ij, r_kj) / (len_r_kj * len_r_kj) * F_i + dot(r_kl, r_kj) / (len_r_kj * len_r_kj) * F_l;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeDistRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int2* __restrict__ atomIndices,       // pair of atom indices\n"
"                            const float4* __restrict__ distanceBounds,  // r1, r2, r3, r4\n"
"                            const float* __restrict__ forceConstants,   // k\n"
"                            int* __restrict__ indexToGlobal,            // array of indices into global arrays\n"
"                            float* __restrict__ energies,               // global array of restraint energies\n"
"                            float3* __restrict__ forceBuffer,           // temporary buffer to hold the force\n"
"                            const int numRestraints) {\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=blockDim.x*gridDim.x) {\n"
"        // get my global index\n"
"        const int globalIndex = indexToGlobal[index];\n"
"\n"
"        // get the distances\n"
"        const float r1 = distanceBounds[index].x;\n"
"        const float r2 = distanceBounds[index].y;\n"
"        const float r3 = distanceBounds[index].z;\n"
"        const float r4 = distanceBounds[index].w;\n"
"\n"
"        // get the force constant\n"
"        const float k = forceConstants[index];\n"
"\n"
"        // get atom indices and compute distance\n"
"        int atomIndexA = atomIndices[index].x;\n"
"        int atomIndexB = atomIndices[index].y;\n"
"        real4 delta = posq[atomIndexA] - posq[atomIndexB];\n"
"        real distSquared = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"        real r = SQRT(distSquared);\n"
"\n"
"        // compute force and energy\n"
"        float energy = 0.0;\n"
"        float dEdR = 0.0;\n"
"        float diff = 0.0;\n"
"        float diff2 = 0.0;\n"
"        float3 f;\n"
"\n"
"        if(r < r1) {\n"
"            energy = k * (r - r1) * (r1 - r2) + 0.5 * k * (r1 - r2) * (r1 - r2);\n"
"            dEdR = k * (r1 - r2);\n"
"        }\n"
"        else if(r < r2) {\n"
"            diff = r - r2;\n"
"            diff2 = diff * diff;\n"
"            energy = 0.5 * k * diff2;\n"
"            dEdR = k * diff;\n"
"        }\n"
"        else if(r < r3) {\n"
"            dEdR = 0.0;\n"
"            energy = 0.0;\n"
"        }\n"
"        else if(r < r4) {\n"
"            diff = r - r3;\n"
"            diff2 = diff * diff;\n"
"            energy = 0.5 * k * diff2;\n"
"            dEdR = k * diff;\n"
"        }\n"
"        else {\n"
"            energy = k * (r - r4) * (r4 - r3) + 0.5 * k * (r4 - r3) * (r4 - r3);\n"
"            dEdR = k * (r4 - r3);\n"
"        }\n"
"\n"
"        // store force into local buffer\n"
"        if (r > 0) {\n"
"            f.x = delta.x * dEdR / r;\n"
"            f.y = delta.y * dEdR / r;\n"
"            f.z = delta.z * dEdR / r;\n"
"        } else {\n"
"            f.x = 0.0;\n"
"            f.y = 0.0;\n"
"            f.z = 0.0;\n"
"        }\n"
"        forceBuffer[index] = f;\n"
"\n"
"        // store energy into global buffer\n"
"        energies[globalIndex] = energy;\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeHyperbolicDistRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int2* __restrict__ atomIndices,       // pair of atom indices\n"
"                            const float4* __restrict__ distanceBounds,  // r1, r2, r3, r4\n"
"                            const float4* __restrict__ params,          // k1, k2, a, b\n"
"                            int* __restrict__ indexToGlobal,            // array of indices into global arrays\n"
"                            float* __restrict__ energies,               // global array of restraint energies\n"
"                            float3* __restrict__ forceBuffer,           // temporary buffer to hold the force\n"
"                            const int numRestraints) {\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=blockDim.x*gridDim.x) {\n"
"        // get my global index\n"
"        const int globalIndex = indexToGlobal[index];\n"
"\n"
"        // get the distances\n"
"        const float r1 = distanceBounds[index].x;\n"
"        const float r2 = distanceBounds[index].y;\n"
"        const float r3 = distanceBounds[index].z;\n"
"        const float r4 = distanceBounds[index].w;\n"
"\n"
"        // get the parameters\n"
"        const float k1 = params[index].x;\n"
"        const float k2 = params[index].y;\n"
"        const float a = params[index].z;\n"
"        const float b = params[index].w;\n"
"\n"
"        // get atom indices and compute distance\n"
"        int atomIndexA = atomIndices[index].x;\n"
"        int atomIndexB = atomIndices[index].y;\n"
"        real4 delta = posq[atomIndexA] - posq[atomIndexB];\n"
"        real distSquared = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"        real r = SQRT(distSquared);\n"
"\n"
"        // compute force and energy\n"
"        float energy = 0.0;\n"
"        float dEdR = 0.0;\n"
"        float diff = 0.0;\n"
"        float diff2 = 0.0;\n"
"        float3 f;\n"
"\n"
"        if(r < r1) {\n"
"            energy = k1 * (r - r1) * (r1 - r2) + 0.5 * k1 * (r1 - r2) * (r1 - r2);\n"
"            dEdR = k1 * (r1 - r2);\n"
"        }\n"
"        else if(r < r2) {\n"
"            diff = r - r2;\n"
"            diff2 = diff * diff;\n"
"            energy = 0.5 * k1 * diff2;\n"
"            dEdR = k1 * diff;\n"
"        }\n"
"        else if(r < r3) {\n"
"            dEdR = 0.0;\n"
"            energy = 0.0;\n"
"        }\n"
"        else if(r < r4) {\n"
"            diff = r - r3;\n"
"            diff2 = diff * diff;\n"
"            energy = 0.5 * k2 * diff2;\n"
"            dEdR = k2 * diff;\n"
"        }\n"
"        else {\n"
"            energy = 0.5 * k2 * (b / (r - r3) + a);\n"
"            dEdR = -0.5 * b * k2 / (r - r3) / (r - r3);\n"
"        }\n"
"\n"
"        // store force into local buffer\n"
"        if (r > 0) {\n"
"            f.x = delta.x * dEdR / r;\n"
"            f.y = delta.y * dEdR / r;\n"
"            f.z = delta.z * dEdR / r;\n"
"        } else {\n"
"            f.x = 0.0;\n"
"            f.y = 0.0;\n"
"            f.z = 0.0;\n"
"        }\n"
"        forceBuffer[index] = f;\n"
"\n"
"        // store energy into global buffer\n"
"        energies[globalIndex] = energy;\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeTorsionRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int4* __restrict__ atomIndices,       // indices of atom_{i,j,k,l}\n"
"                            const float3* __restrict__ params,          // phi, deltaPhi, forceConstant\n"
"                            int* __restrict__ indexToGlobal,            // array of indices into global arrays\n"
"                            float* __restrict__ energies,               // global array of restraint energies\n"
"                            float3* __restrict__ forceBuffer,           // temporary buffer to hold the force\n"
"                                                                        // forceBuffer[index*4] -> atom_i\n"
"                                                                        // forceBuffer[index*4 + 3] -> atom_l\n"
"                            const int numRestraints) {\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=gridDim.x*blockDim.x) {\n"
"        // get my global index\n"
"        int globalIndex = indexToGlobal[index];\n"
"\n"
"        // get the atom indices\n"
"        int4 indices = atomIndices[index];\n"
"        int atom_i = indices.x;\n"
"        int atom_j = indices.y;\n"
"        int atom_k = indices.z;\n"
"        int atom_l = indices.w;\n"
"\n"
"        // compute the angle and related quantities\n"
"        float3 r_ij, r_kj, r_kl;\n"
"        float3 m, n;\n"
"        float len_r_kj;\n"
"        float len_m;\n"
"        float len_n;\n"
"        float phi;\n"
"        computeTorsionAngle(posq, atom_i, atom_j, atom_k, atom_l,\n"
"                r_ij, r_kj, r_kl, m, n, len_r_kj, len_m, len_n,  phi);\n"
"\n"
"        // compute E and dE/dphi\n"
"        float phiEquil = params[index].x;\n"
"        float phiDelta = params[index].y;\n"
"        float forceConst = params[index].z;\n"
"\n"
"        float phiDiff = phi - phiEquil;\n"
"        if (phiDiff < -180.) {\n"
"            phiDiff += 360.;\n"
"        } else if (phiDiff > 180.) {\n"
"            phiDiff -= 360.;\n"
"        }\n"
"\n"
"        float energy = 0.0;\n"
"        float dEdPhi = 0.0;\n"
"        if (phiDiff < -phiDelta) {\n"
"            energy = 0.5 * forceConst * (phiDiff + phiDelta) * (phiDiff + phiDelta);\n"
"            dEdPhi = forceConst * (phiDiff + phiDelta);\n"
"        }\n"
"        else if(phiDiff > phiDelta) {\n"
"            energy = 0.5 * forceConst * (phiDiff - phiDelta) * (phiDiff - phiDelta);\n"
"            dEdPhi = forceConst * (phiDiff - phiDelta);\n"
"        }\n"
"        else{\n"
"            energy = 0.0;\n"
"            dEdPhi = 0.0;\n"
"        }\n"
"\n"
"        energies[globalIndex] = energy;\n"
"\n"
"        computeTorsionForce(dEdPhi, r_ij, r_kj, r_kl, m, n, len_r_kj, len_m, len_n,\n"
"                forceBuffer[4 * index + 0], forceBuffer[4 * index + 1],\n"
"                forceBuffer[4 * index + 2], forceBuffer[4 * index + 3]);\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeDistProfileRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int2* __restrict__ atomIndices,       // pair of atom indices\n"
"                            const float2* __restrict__ distRanges,      // upper and lower bounds of spline\n"
"                            const int* __restrict__ nBins,              // number of bins\n"
"                            const float4* __restrict__ splineParams,    // a0, a1, a2, a3\n"
"                            const int2* __restrict__ paramBounds,       // upper and lower bounds for each spline\n"
"                            const float* __restrict__ scaleFactor,      // scale factor for energies and forces\n"
"                            const int* __restrict__ indexToGlobal,      // index of this restraint in the global array\n"
"                            float* __restrict__ restraintEnergies,      // global energy of each restraint\n"
"                            float3* __restrict__ restraintForce,        // cache the forces for application later\n"
"                            const int numRestraints ) {\n"
"\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=blockDim.x*gridDim.x) {\n"
"        // get my global index\n"
"        int globalIndex = indexToGlobal[index];\n"
"\n"
"        // get atom indices and compute distance\n"
"        int atomIndexA = atomIndices[index].x;\n"
"        int atomIndexB = atomIndices[index].y;\n"
"\n"
"        real4 delta = posq[atomIndexA] - posq[atomIndexB];\n"
"        real distSquared = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"        real r = SQRT(distSquared);\n"
"\n"
"        // compute bin\n"
"        int bin = (int)( floor((r - distRanges[index].x) / (distRanges[index].y - distRanges[index].x) * nBins[index]) );\n"
"\n"
"        // compute the force and energy\n"
"        float energy = 0.0;\n"
"        float dEdR = 0.0;\n"
"        float binWidth = (distRanges[index].y - distRanges[index].x) / nBins[index];\n"
"        if (bin < 0){\n"
"            energy = scaleFactor[index] * splineParams[paramBounds[index].x].x;\n"
"        }\n"
"        else if (bin >= nBins[index]) {\n"
"            energy = scaleFactor[index] * (splineParams[paramBounds[index].y - 1].x +\n"
"                                           splineParams[paramBounds[index].y - 1].y +\n"
"                                           splineParams[paramBounds[index].y - 1].z +\n"
"                                           splineParams[paramBounds[index].y - 1].w);\n"
"        }\n"
"        else {\n"
"            float t = (r - bin * binWidth + distRanges[index].x) / binWidth;\n"
"            float a0 = splineParams[ paramBounds[index].x + bin ].x;\n"
"            float a1 = splineParams[ paramBounds[index].x + bin ].y;\n"
"            float a2 = splineParams[ paramBounds[index].x + bin ].z;\n"
"            float a3 = splineParams[ paramBounds[index].x + bin ].w;\n"
"            energy = scaleFactor[index] * (a0 + a1 * t + a2 * t * t + a3 * t * t * t);\n"
"            dEdR = scaleFactor[index] * (a1 + 2.0 * a2 * t + 3.0 * a3 * t * t) / binWidth;\n"
"        }\n"
"\n"
"        // store force into local buffer\n"
"        float3 f;\n"
"        f.x = delta.x * dEdR / r;\n"
"        f.y = delta.y * dEdR / r;\n"
"        f.z = delta.z * dEdR / r;\n"
"        restraintForce[index] = f;\n"
"\n"
"        // store energy into global buffer\n"
"        restraintEnergies[globalIndex] = energy;\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeTorsProfileRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int4* __restrict__ atomIndices0,      // i,j,k,l for torsion 0\n"
"                            const int4* __restrict__ atomIndices1,      // i,j,k,l for torsion 1\n"
"                            const int* __restrict__ nBins,              // number of bins\n"
"                            const float4* __restrict__ params0,         // a0 - a3\n"
"                            const float4* __restrict__ params1,         // a4 - a7\n"
"                            const float4* __restrict__ params2,         // a8 - a11\n"
"                            const float4* __restrict__ params3,         // a12 - a15\n"
"                            const int2* __restrict__ paramBounds,       // upper and lower bounds for each spline\n"
"                            const float* __restrict__ scaleFactor,      // scale factor for energies and forces\n"
"                            const int* __restrict__ indexToGlobal,      // index of this restraint in the global array\n"
"                            float* __restrict__ restraintEnergies,      // global energy of each restraint\n"
"                            float3* __restrict__ forceBuffer,        // cache the forces for application later\n"
"                            const int numRestraints ) {\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=gridDim.x*blockDim.x) {\n"
"        // get my global index\n"
"        int globalIndex = indexToGlobal[index];\n"
"\n"
"        // compute phi\n"
"        int phi_atom_i = atomIndices0[index].x;\n"
"        int phi_atom_j = atomIndices0[index].y;\n"
"        int phi_atom_k = atomIndices0[index].z;\n"
"        int phi_atom_l = atomIndices0[index].w;\n"
"        float3 phi_r_ij, phi_r_kj, phi_r_kl;\n"
"        float3 phi_m, phi_n;\n"
"        float phi_len_r_kj;\n"
"        float phi_len_m;\n"
"        float phi_len_n;\n"
"        float phi;\n"
"        computeTorsionAngle(posq, phi_atom_i, phi_atom_j, phi_atom_k, phi_atom_l,\n"
"                phi_r_ij, phi_r_kj, phi_r_kl, phi_m, phi_n, phi_len_r_kj, phi_len_m, phi_len_n, phi);\n"
"\n"
"        // compute psi\n"
"        int psi_atom_i = atomIndices1[index].x;\n"
"        int psi_atom_j = atomIndices1[index].y;\n"
"        int psi_atom_k = atomIndices1[index].z;\n"
"        int psi_atom_l = atomIndices1[index].w;\n"
"        float3 psi_r_ij, psi_r_kj, psi_r_kl;\n"
"        float3 psi_m, psi_n;\n"
"        float psi_len_r_kj;\n"
"        float psi_len_m;\n"
"        float psi_len_n;\n"
"        float psi;\n"
"        computeTorsionAngle(posq, psi_atom_i, psi_atom_j, psi_atom_k, psi_atom_l,\n"
"                psi_r_ij, psi_r_kj, psi_r_kl, psi_m, psi_n, psi_len_r_kj, psi_len_m, psi_len_n, psi);\n"
"\n"
"        // compute bin indices\n"
"        int i = (int)(floor((phi + 180.)/360. * nBins[index]));\n"
"        int j = (int)(floor((psi + 180.)/360. * nBins[index]));\n"
"\n"
"        if (i >= nBins[index]) {\n"
"            i = 0;\n"
"            phi -= 360.;\n"
"        }\n"
"        if (i < 0) {\n"
"            i = nBins[index] - 1;\n"
"            phi += 360.;\n"
"        }\n"
"\n"
"        if (j >= nBins[index]) {\n"
"            j = 0;\n"
"            psi -= 360.;\n"
"        }\n"
"        if (j < 0) {\n"
"            j = nBins[index] - 1;\n"
"            psi += 360.;\n"
"        }\n"
"\n"
"        float delta = 360. / nBins[index];\n"
"        float u = (phi - i * delta + 180.) / delta;\n"
"        float v = (psi - j * delta + 180.) / delta;\n"
"\n"
"        int pi = paramBounds[index].x + i * nBins[index] + j;\n"
"\n"
"        float energy = params0[pi].x         + params0[pi].y * v       + params0[pi].z * v*v       + params0[pi].w * v*v*v +\n"
"                       params1[pi].x * u     + params1[pi].y * u*v     + params1[pi].z * u*v*v     + params1[pi].w * u*v*v*v +\n"
"                       params2[pi].x * u*u   + params2[pi].y * u*u*v   + params2[pi].z * u*u*v*v   + params2[pi].w * u*u*v*v*v +\n"
"                       params3[pi].x * u*u*u + params3[pi].y * u*u*u*v + params3[pi].z * u*u*u*v*v + params3[pi].w * u*u*u*v*v*v;\n"
"        energy = energy * scaleFactor[index];\n"
"\n"
"        float dEdPhi = params1[pi].x         + params1[pi].y * v     + params1[pi].z * v*v     + params1[pi].w * v*v*v +\n"
"                       params2[pi].x * 2*u   + params2[pi].y * 2*u*v   + params2[pi].z * 2*u*v*v   + params2[pi].w * 2*u*v*v*v +\n"
"                       params3[pi].x * 3*u*u + params3[pi].y * 3*u*u*v + params3[pi].z * 3*u*u*v*v + params3[pi].w * 3*u*u*v*v*v;\n"
"        dEdPhi = dEdPhi * scaleFactor[index] / delta;\n"
"\n"
"        float dEdPsi = params0[pi].y         + params0[pi].z * 2*v       + params0[pi].w * 3*v*v +\n"
"                       params1[pi].y * u     + params1[pi].z * u*2*v     + params1[pi].w * u*3*v*v +\n"
"                       params2[pi].y * u*u   + params2[pi].z * u*u*2*v   + params2[pi].w * u*u*3*v*v +\n"
"                       params3[pi].y * u*u*u + params3[pi].z * u*u*u*2*v + params3[pi].w * u*u*u*3*v*v;\n"
"        dEdPsi = dEdPsi * scaleFactor[index] / delta;\n"
"\n"
"        restraintEnergies[globalIndex] = energy;\n"
"\n"
"        computeTorsionForce(dEdPhi, phi_r_ij, phi_r_kj, phi_r_kl, phi_m, phi_n, phi_len_r_kj, phi_len_m, phi_len_n,\n"
"                forceBuffer[8 * index + 0], forceBuffer[8 * index + 1],\n"
"                forceBuffer[8 * index + 2], forceBuffer[8 * index + 3]);\n"
"        computeTorsionForce(dEdPsi, psi_r_ij, psi_r_kj, psi_r_kl, psi_m, psi_n, psi_len_r_kj, psi_len_m, psi_len_n,\n"
"                forceBuffer[8 * index + 4], forceBuffer[8 * index + 5],\n"
"                forceBuffer[8 * index + 6], forceBuffer[8 * index + 7]);\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeGMMRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int numRestraints,                    // number of restraints\n"
"                            const int4* __restrict__ params,            // nPairs, nComponents, globalIndices\n"
"                            const int2* __restrict__ offsets,           // atomBlockOffset, dataBlockOffset\n"
"                            const int* __restrict__ atomIndices,        // atom indices\n"
"                            const float* __restrict__ data,             // weights, means, diags, offdiags\n"
"                            float* __restrict__ energies,               // global array of restraint energies\n"
"                            float3* __restrict__ forceBuffer) {         // temporary buffer to hold the force\n"
"    extern __shared__ volatile char scratch[];\n"
"\n"
"\n"
"    int tid = threadIdx.x;\n"
"    int warp = tid / 32;\n"
"    int lane = tid % 32;\n"
"\n"
"    float* distances = (float*)&scratch[0];\n"
"    float* probabilities = (float*)&scratch[16*32*sizeof(float)];\n"
"\n"
"    distances[tid] = 0.0;\n"
"    probabilities[tid] = 0.0;\n"
"\n"
"    for (int index=16*blockIdx.x + warp; index<numRestraints; index+=16*gridDim.x) {\n"
"        int nPairs = params[index].x;\n"
"        int nComponents = params[index].y;\n"
"        int globalIndex = params[index].z;\n"
"        float scale = (float)(params[index].w) * 1e-6;\n"
"\n"
"        int atomBlockOffset = offsets[index].x;\n"
"        int dataBlockOffset = offsets[index].y;\n"
"\n"
"        // compute my distance\n"
"        if (lane < nPairs) {\n"
"            int atomIndex1 = atomIndices[atomBlockOffset + 2 * lane];\n"
"            int atomIndex2 = atomIndices[atomBlockOffset + 2 * lane + 1];\n"
"\n"
"            real4 delta = posq[atomIndex1] - posq[atomIndex2];\n"
"            real distSquared = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"            real r = SQRT(distSquared);\n"
"            distances[tid] = r;\n"
"        }\n"
"        __syncthreads();\n"
"\n"
"\n"
"        float minsum = 9e99;\n"
"\n"
"        // compute my probability\n"
"        const int blockSize = 1 + 2*nPairs + nPairs*(nPairs-1)/2;\n"
"        if (lane < nComponents) {\n"
"            // compute offsets into data array\n"
"            const float weight = data[dataBlockOffset + lane*blockSize];\n"
"            const float* means = &data[dataBlockOffset + lane*blockSize + 1];\n"
"            const float* diags = &data[dataBlockOffset + lane*blockSize + nPairs + 1];\n"
"            const float* offdiags = &data[dataBlockOffset + lane*blockSize + 2*nPairs + 1];\n"
"            float sum = 0;\n"
"\n"
"            // do the diagonal part\n"
"            for (int i=0; i<nPairs; i++) {\n"
"                float mean = means[i];\n"
"                float diag = diags[i] * scale;\n"
"                float dist = distances[32 * warp + i];\n"
"                sum += (mean - dist) * (mean - dist) * diag;\n"
"            }\n"
"\n"
"            // do the off diagonal part\n"
"            int count = 0;\n"
"            for (int i=0; i<nPairs; i++) {\n"
"                for (int j=i+1; j<nPairs; j++) {\n"
"                    float meani = means[i];\n"
"                    float meanj = means[j];\n"
"                    float coeff = 2 * offdiags[count] * scale;\n"
"                    float disti = distances[32 * warp + i];\n"
"                    float distj = distances[32 * warp + j];\n"
"                    sum += (disti - meani) * (distj - meanj) * coeff;\n"
"                    count++;\n"
"                }\n"
"            }\n"
"            probabilities[tid] = sum;\n"
"\n"
"            __syncthreads();\n"
"\n"
"            for (int i=0; i<nComponents; i++) {\n"
"                if(probabilities[32 * warp + i] < minsum) {\n"
"                    minsum = probabilities[32 * warp + i];\n"
"                }\n"
"            }\n"
"            __syncthreads();\n"
"\n"
"            probabilities[tid] = weight * exp(-0.5 * (sum - minsum));\n"
"            __syncthreads();\n"
"        }\n"
"\n"
"        // compute and store forces\n"
"        float totalProb = 0;\n"
"        for (int i=0; i<nComponents; i++) {\n"
"            totalProb += probabilities[32 * warp + i];\n"
"        }\n"
"\n"
"        if (lane < nPairs) {\n"
"            float dEdr = 0;\n"
"\n"
"            // compute diagonal part of force\n"
"            for (int i=0; i<nComponents; i++) {\n"
"                float distance = distances[32 * warp + lane];\n"
"                float mean = data[dataBlockOffset + i*blockSize + lane + 1];\n"
"                float diag = data[dataBlockOffset + i*blockSize + nPairs + lane + 1];\n"
"                dEdr += 2.48 * probabilities[32 * warp + i] / totalProb * (distance - mean) * diag * scale;\n"
"            }\n"
"\n"
"            // compute off diagonal part of force\n"
"            for (int i=0; i<nComponents; i++) {\n"
"                for (int k=0; k<nPairs; k++) {\n"
"                    if (k != lane) {\n"
"                        float r = distances[32 * warp + k];\n"
"                        float mu = data[dataBlockOffset + i*blockSize + k + 1];\n"
"                        int coeffIndex = 0;\n"
"                        if (k > lane) {\n"
"                            coeffIndex = nPairs*(nPairs-1)/2 - (nPairs-lane)*((nPairs-lane)-1)/2 + k - lane - 1;\n"
"                        } else {\n"
"                            coeffIndex = nPairs*(nPairs-1)/2 - (nPairs-k)*((nPairs-k)-1)/2 + lane - k - 1;\n"
"                        }\n"
"                        float coeff = data[dataBlockOffset + i*blockSize + 1 + 2*nPairs + coeffIndex];\n"
"                        dEdr += 2.48 * probabilities[32 * warp + i] / totalProb * (r - mu) * coeff * scale;\n"
"                    }\n"
"                }\n"
"            }\n"
"            int atomIndex1 = atomIndices[atomBlockOffset + 2 * lane];\n"
"            int atomIndex2 = atomIndices[atomBlockOffset + 2 * lane + 1];\n"
"            real4 delta = posq[atomIndex1] - posq[atomIndex2];\n"
"            float4 f = dEdr * delta / distances[32 * warp + lane];\n"
"            forceBuffer[atomBlockOffset + lane].x = f.x;\n"
"            forceBuffer[atomBlockOffset + lane].y = f.y;\n"
"            forceBuffer[atomBlockOffset + lane].z = f.z;\n"
"        }\n"
"\n"
"        // compute and store the energy\n"
"        if (lane == 0) {\n"
"            float energy = -2.48 * (log(totalProb) - 0.5 * minsum);\n"
"            energies[globalIndex] = energy;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void computeEmapRest(\n"
"                            const real4* __restrict__ posq, \n"
"                            const int* __restrict__ atomIndices, \n"
"                            const float3* __restrict__ grids,\n"
"                            const float* __restrict__ mu,\n"
"                            const float* __restrict__ blur,\n"
"                            const float* __restrict__ bandwidth,\n"
"                            const float* __restrict__ emap_weights,\n"
"                            int* __restrict__ indexToGlobal,\n"
"                            float* __restrict__ energies, \n"
"                            float3* __restrict__ forceBuffer,\n"
"                            const int numRestraints,\n"
"                            const int numEmapGrids,\n"
"                            const int numEmapAtoms) {\n"
"    int globalIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float emap_energy = 0; \n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numEmapAtoms; index+=blockDim.x*gridDim.x) {\n"
"        int atomIndex = atomIndices[index];\n"
"        float emap_weight = emap_weights[index];\n"
"        //compute force and energy\n"
"        float energy = 0;        \n"
"        float3 f = make_float3(0,0,0);\n"
"        for (int grid_index = blockIdx.y*blockDim.y+threadIdx.y; grid_index < numEmapGrids; grid_index+=blockDim.y*gridDim.y)\n"
"        {\n"
"            float3 diff = trimTo3(posq[atomIndex]) - grids[grid_index];\n"
"            float diffSquared = diff.x * diff.x + diff.y * diff.y + diff.z * diff.z;\n"
"            float r = SQRT(diffSquared);\n"
"            float blurred = bandwidth[grid_index] * bandwidth[grid_index] + (1-blur[grid_index]) * (1-blur[grid_index]);\n"
"            energy += emap_weight * mu[grid_index] * exp(-1 * diffSquared / (2 * blurred));\n"
"            if (r > 0) {\n"
"                f += emap_weight * mu[grid_index] / (blurred) * exp(-1 * diffSquared / (2 * blurred)) * diff;\n"
"            }\n"
"            __syncthreads();\n"
"        }\n"
"        forceBuffer[index] = f;\n"
"        energies[globalIndex] += energy;\n"
"        __syncthreads();\n"
"    }\n"
"}\n"
"                            \n"
"extern \"C\" __global__ void evaluateAndActivate(\n"
"        const int numGroups,\n"
"        const int* __restrict__ numActiveArray,\n"
"        const int2* __restrict__ boundsArray,\n"
"        const int* __restrict__ pristineIndexArray,\n"
"        int* __restrict__ tempIndexArray,\n"
"        const float* __restrict__ energyArray,\n"
"        float* __restrict__ activeArray,\n"
"        float* __restrict__ targetEnergyArray)\n"
"{\n"
"    // This kernel computes which restraints are active within each group.\n"
"    // It uses \"warp-level\" programming to do this, where each warp within\n"
"    // a threadblock computes the results for a single group. All threads\n"
"    // within each group are implicity synchronized at the hardware\n"
"    // level.\n"
"\n"
"    // These are runtime parameters set tby the C++ code.\n"
"    const int groupsPerBlock = GROUPSPERBLOCK;\n"
"    const int maxGroupSize = MAXGROUPSIZE;\n"
"\n"
"    // Because each warp is computing a separate interaction, we need to\n"
"    // keep track of which block we are acting on and our index within\n"
"    // that warp.\n"
"    const int groupOffsetInBlock = threadIdx.x / 32;\n"
"    const int threadOffsetInWarp = threadIdx.x % 32;\n"
"\n"
"    // We store the energies and indices into scratch buffers. These scratch\n"
"    // buffers are also used for reductions within each warp.\n"
"    extern __shared__ volatile char scratch[];\n"
"    volatile float* warpScratchEnergy = (float*)&scratch[groupOffsetInBlock*maxGroupSize*(sizeof(float)+sizeof(int))];\n"
"    volatile int* warpScratchIndices = (int*)&scratch[groupOffsetInBlock*maxGroupSize*(sizeof(float)+sizeof(int)) +\n"
"                                                      maxGroupSize*sizeof(float)];\n"
"    volatile float* warpReductionBuffer = (float*)&scratch[groupOffsetInBlock*32*sizeof(float)];\n"
"\n"
"    // each warp loads the energies and indices for a group\n"
"    for (int groupIndex=groupsPerBlock*blockIdx.x+groupOffsetInBlock; groupIndex<numGroups; groupIndex+=groupsPerBlock*gridDim.x) {\n"
"        const int numActive = numActiveArray[groupIndex];\n"
"        const int start = boundsArray[groupIndex].x;\n"
"        const int end = boundsArray[groupIndex].y;\n"
"        const int length = end - start;\n"
"        const bool applyAll = (numActive == length);\n"
"\n"
"        // copy the energies to shared memory and setup indices\n"
"        if (!applyAll) {\n"
"            for(int i=threadOffsetInWarp; i<length; i+=32) {\n"
"                const float energy = energyArray[pristineIndexArray[i + start]];\n"
"                warpScratchIndices[i] = i;\n"
"                warpScratchEnergy[i] = energy;\n"
"            }\n"
"        }\n"
"\n"
"        // now, we run the quick select algorithm.\n"
"        // this is not parallelized, so we only run it on one thread\n"
"        // per block.\n"
"        if (threadOffsetInWarp==0) {\n"
"            float energyCut = 0.0;\n"
"            if (!applyAll) {\n"
"                energyCut = quick_select_float((const float*)warpScratchEnergy, (int *)warpScratchIndices, length, numActive-1);\n"
"            }\n"
"            else {\n"
"                energyCut = 9.99e99;\n"
"            }\n"
"            warpScratchEnergy[0] = energyCut;\n"
"        }\n"
"\n"
"\n"
"        // now we're back on all threads again\n"
"        float energyCut = warpScratchEnergy[0];\n"
"        float thisActive = 0.0;\n"
"        float thisEnergy = 0.0;\n"
"\n"
"        // we are going to start writing to warpReductionBuffer,\n"
"        // which may overlap with the warpScratch* buffers, so\n"
"        // we need to make sure that all threads are done first.\n"
"        __syncthreads();\n"
"\n"
"        // reset the reduction buffers to zero\n"
"        warpReductionBuffer[threadOffsetInWarp] = 0.0;\n"
"\n"
"        // sum up the energy for each restraint\n"
"        for(int i=threadOffsetInWarp+start; i<end; i+=32) {\n"
"            thisEnergy = energyArray[pristineIndexArray[i]];\n"
"            thisActive = (float)(thisEnergy <= energyCut);\n"
"            activeArray[pristineIndexArray[i]] = thisActive;\n"
"            warpReductionBuffer[threadOffsetInWarp] += thisActive * thisEnergy;\n"
"        }\n"
"\n"
"        // now we do a parallel reduction within each warp\n"
"        int totalThreads = 32;\n"
"        int index2 = 0;\n"
"        while (totalThreads > 1) {\n"
"            int halfPoint = (totalThreads >> 1);\n"
"            if (threadOffsetInWarp < halfPoint) {\n"
"                index2 = threadOffsetInWarp + halfPoint;\n"
"                warpReductionBuffer[threadOffsetInWarp] += warpReductionBuffer[index2];\n"
"            }\n"
"            totalThreads = halfPoint;\n"
"        }\n"
"\n"
"        // now store the energy for this group\n"
"        if (threadOffsetInWarp == 0) {\n"
"            targetEnergyArray[groupIndex] = warpReductionBuffer[0];\n"
"        }\n"
"\n"
"        // make sure we're all done before we start again\n"
"        __syncthreads();\n"
"    }\n"
"}\n"
"\n"
"\n"
"__device__ void findMinMax(int length, volatile float* energyArray, volatile float* minBuffer, volatile float* maxBuffer) {\n"
"    const int tid = threadIdx.x;\n"
"    float energy;\n"
"    float min = 9.9e99;\n"
"    float max = -9.9e99;\n"
"    // Each thread computes the min and max for it's energies and stores them in the buffers\n"
"    for (int i=tid; i<length; i+=blockDim.x) {\n"
"        energy = energyArray[i];\n"
"        if (energy < min) {\n"
"            min = energy;\n"
"        }\n"
"        if (energy > max) {\n"
"            max = energy;\n"
"        }\n"
"    }\n"
"    minBuffer[tid] = min;\n"
"    maxBuffer[tid] = max;\n"
"    __syncthreads();\n"
"\n"
"    // Now we do a parallel reduction\n"
"    int totalThreads = blockDim.x;\n"
"    int index2 = 0;\n"
"    float temp = 0;\n"
"    while (totalThreads > 1) {\n"
"        int halfPoint = (totalThreads >> 1);\n"
"        if (tid < halfPoint) {\n"
"            index2 = tid + halfPoint;\n"
"            temp = minBuffer[index2];\n"
"            if (temp < minBuffer[tid]) {\n"
"                minBuffer[tid] = temp;\n"
"            }\n"
"            temp = maxBuffer[index2];\n"
"            if (temp > maxBuffer[tid]) {\n"
"                maxBuffer[tid] = temp;\n"
"            }\n"
"        }\n"
"        __syncthreads();\n"
"        totalThreads = halfPoint;\n"
"    }\n"
"    __syncthreads();\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void evaluateAndActivateCollections(\n"
"        const int numCollections,\n"
"        const int* __restrict__ numActiveArray,\n"
"        const int2* __restrict__ boundsArray,\n"
"        const int* __restrict__ indexArray,\n"
"        const float* __restrict__ energyArray,\n"
"        float* __restrict__ activeArray,\n"
"        int * __restrict__ encounteredError)\n"
"{\n"
"    const float TOLERANCE = 1e-4;\n"
"    const int maxCollectionSize = MAXCOLLECTIONSIZE;\n"
"    const int tid = threadIdx.x;\n"
"    const int warp = tid / 32;\n"
"    const int lane = tid % 32;  // which thread are we within this warp\n"
"\n"
"    // shared memory:\n"
"    // energyBuffer: maxCollectionSize floats\n"
"    // min/max Buffer: gridDim.x floats\n"
"    // binCounts: blockDim.x ints\n"
"    extern __shared__ volatile char collectionScratch[];\n"
"    volatile float* energyBuffer = (float*)&collectionScratch[0];\n"
"    volatile float* minBuffer = (float*)&collectionScratch[maxCollectionSize*sizeof(float)];\n"
"    volatile float* maxBuffer = (float*)&collectionScratch[(maxCollectionSize+blockDim.x)*sizeof(float)];\n"
"    volatile int* binCounts = (int*)&collectionScratch[(maxCollectionSize+2*blockDim.x)*sizeof(float)];\n"
"    volatile int* bestBin = (int*)&(collectionScratch[(maxCollectionSize + 2 * blockDim.x) * sizeof(float) +\n"
"                                                      blockDim.x * sizeof(int)]);\n"
"\n"
"    for (int collIndex=blockIdx.x; collIndex<numCollections; collIndex+=gridDim.x) {\n"
"        // we need to find the value of the cutoff energy below, then we will\n"
"        // activate all groups with lower energy\n"
"        float energyCutoff = 0.0;\n"
"\n"
"        int numActive = numActiveArray[collIndex];\n"
"        int start = boundsArray[collIndex].x;\n"
"        int end = boundsArray[collIndex].y;\n"
"        int length = end - start;\n"
"\n"
"        // load the energy buffer for this collection\n"
"        for (int i=tid; i<length; i+=blockDim.x) {\n"
"            const float energy = energyArray[indexArray[start + i]];\n"
"            energyBuffer[i] = energy;\n"
"        }\n"
"        __syncthreads();\n"
"\n"
"        findMinMax(length, energyBuffer, minBuffer, maxBuffer);\n"
"        float min = minBuffer[0];\n"
"        float max = maxBuffer[0];\n"
"        float delta = max - min;\n"
"\n"
"\n"
"        // If all of the energies are the same, they should all be active.\n"
"        // Note: we need to break out here in this case, as otherwise delta\n"
"        // will be zero and bad things will happen\n"
"        if (fabs(max-min) < TOLERANCE) {\n"
"            energyCutoff = max;\n"
"        } else {\n"
"            // Here we need to find the k'th highest energy. We do this using a recursive,\n"
"            // binning and counting strategy. We divide the interval (min, max) into blockDim.x\n"
"            // bins. We assign each energy to a bin, increment the count, and update\n"
"            // the min and max. Then, we find the bin that contains the k'th lowest energy. If\n"
"            // min==max for this bin, then we are done. Otherwise, we set the new (min, max) for\n"
"            // the bins and recompute, assigning energies less than min to bin 0.\n"
"\n"
"            // loop until we break out at convergence\n"
"            for (;;) {\n"
"\n"
"                // check to see if have encountered NaN, which will\n"
"                // result in an infinite loop\n"
"                if(tid==0) {\n"
"                    if (!isfinite(min) || !isfinite(max)) {\n"
"                        *encounteredError = 1;\n"
"                    }\n"
"                }\n"
"                // zero out the buffers\n"
"                binCounts[tid] = 0;\n"
"                minBuffer[tid] = 9.0e99;\n"
"                maxBuffer[tid] = 0.0;\n"
"                __syncthreads();\n"
"\n"
"                // If we hit a NaN then abort early now that encounteredError is set.\n"
"                // This will cause an exception on the C++ side\n"
"                if (*encounteredError) {\n"
"                    return;\n"
"                }\n"
"\n"
"                // loop over all energies\n"
"                for (int i=tid; i<length; i+=blockDim.x) {\n"
"                    float energy = energyBuffer[i];\n"
"                    // compute which bin this energy lies in\n"
"                    int index = float2int(floorf((blockDim.x-1) / delta * (energy - min)));\n"
"\n"
"                    // we only count entries that lie within min and max\n"
"                    if ( (index >= 0) && (index < blockDim.x) ) {\n"
"\n"
"                        // increment the counter using atomic function\n"
"                        atomicAdd(&((int *)binCounts)[index], 1);\n"
"                        // update the min and max bounds for the bin using atomic functions\n"
"                        // note we need to cast to an integer, but floating point values\n"
"                        // still compare correctly when represented as integers\n"
"                        // this assumes that all energies are >0\n"
"                        atomicMin((unsigned int*)&((float *)minBuffer)[index], __float_as_int(energy));\n"
"                        atomicMax((unsigned int*)&((float *)maxBuffer)[index], __float_as_int(energy));\n"
"                    }\n"
"                }\n"
"                // make sure all threads are done\n"
"                __syncthreads();\n"
"\n"
"                // Now we need to perform a cumulative sum, which is surprisingly\n"
"                // hard to get both correct and fast. We use a two pass, in-place\n"
"                // algorithm.\n"
"                //\n"
"                // We use the algorihm given in:\n"
"                // http://cuda.ac.upc.edu/sites/cuda.ac.upc.edu/files/lectures/patc_bsc_scan_2.pdf\n"
"\n"
"                // First, the upsweep.\n"
"                int stride = 1;\n"
"                while(stride < blockDim.x) {\n"
"                    int index = (tid + 1) * stride * 2 - 1;\n"
"                    if(index < blockDim.x) {\n"
"                        binCounts[index] += binCounts[index - stride];\n"
"                    }\n"
"\n"
"                    stride = stride * 2;\n"
"                    __syncthreads();\n"
"                }\n"
"\n"
"                // Now, the downsweep.\n"
"                for(stride=blockDim.x / 4; stride>0; stride /= 2) {\n"
"                    __syncthreads();\n"
"\n"
"                    int index = (tid + 1) * stride * 2 - 1;\n"
"                    if(index + stride < blockDim.x) {\n"
"                        binCounts[index + stride] += binCounts[index];\n"
"                    }\n"
"                }\n"
"                __syncthreads();\n"
"\n"
"\n"
"                // now we need to find the bin containing the k'th highest value\n"
"                // we use a single warp, where each thread looks at a block of 32 entries\n"
"                // to find the smallest index where the cumulative sum is >= numActive\n"
"                // we set flag if we find one\n"
"                // this section uses implicit synchronization between threads in a single warp\n"
"\n"
"                if(tid == 0) {\n"
"                    *bestBin = blockDim.x;\n"
"                }\n"
"                __syncthreads();\n"
"\n"
"                if(binCounts[tid] >= numActive) {\n"
"                    atomicMin((int *)bestBin, tid);\n"
"                }\n"
"                __syncthreads();\n"
"\n"
"                if(tid==0) {\n"
"                    if(*bestBin==blockDim.x) {\n"
"                        *encounteredError = 2;\n"
"                    }\n"
"                }\n"
"                __syncthreads();\n"
"\n"
"                // bail out if we still have an invalid value in bestBin\n"
"                if(*encounteredError) {\n"
"                    return;\n"
"                }\n"
"\n"
"                const float binMin = minBuffer[*bestBin];\n"
"                const float binMax = maxBuffer[*bestBin];\n"
"\n"
"                //  if all energies in this bin are the same, then we are done\n"
"                if (fabs(binMin-binMax) < TOLERANCE) {\n"
"                    energyCutoff = binMax;\n"
"                    break;\n"
"                }\n"
"\n"
"                // if this bin ends exactly on the k'th lowest energy, then we are done\n"
"                if (binCounts[*bestBin] == numActive) {\n"
"                    energyCutoff = binMax;\n"
"                    break;\n"
"                }\n"
"\n"
"                // otherwise, the correct value lies somewhere within this bin\n"
"                // it will between binMin and binMax and we need to find the\n"
"                // binCounts[*bestBin] - numActive 'th element\n"
"                // we loop through again searching with these updated parameters\n"
"                min = binMin;\n"
"                max = binMax;\n"
"                delta = max - min;\n"
"                numActive = binCounts[*bestBin] - numActive;\n"
"                __syncthreads();\n"
"            }\n"
"        }\n"
"\n"
"        // now we know the energyCutoff, so apply it to each group\n"
"        for (int i=tid; i<length; i+=blockDim.x) {\n"
"            if (energyBuffer[i] <= energyCutoff) {\n"
"                activeArray[indexArray[i + start]] = 1.0;\n"
"            }\n"
"            else {\n"
"                activeArray[indexArray[i + start]] = 0.0;\n"
"            }\n"
"        }\n"
"        __syncthreads();\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyGroups(\n"
"                            float* __restrict__ groupActive,\n"
"                            float* __restrict__ restraintActive,\n"
"                            const int2* __restrict__ bounds,\n"
"                            int numGroups) {\n"
"    for (int groupIndex=blockIdx.x; groupIndex<numGroups; groupIndex+=gridDim.x) {\n"
"        float active = groupActive[groupIndex];\n"
"        for (int i=bounds[groupIndex].x + threadIdx.x; i<bounds[groupIndex].y; i+=blockDim.x) {\n"
"            restraintActive[i] *= active;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyDistRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int2* __restrict__ atomIndices,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numDistRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numDistRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            int index1 = atomIndices[restraintIndex].x;\n"
"            int index2 = atomIndices[restraintIndex].y;\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"            float3 f = restForces[restraintIndex];\n"
"            atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (-f.x*0x100000000)));\n"
"            atomicAdd(&force[index1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.y*0x100000000)));\n"
"            atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[index2], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"            atomicAdd(&force[index2  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"            atomicAdd(&force[index2 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyHyperbolicDistRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int2* __restrict__ atomIndices,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numDistRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numDistRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            int index1 = atomIndices[restraintIndex].x;\n"
"            int index2 = atomIndices[restraintIndex].y;\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"            float3 f = restForces[restraintIndex];\n"
"\n"
"            atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (-f.x*0x100000000)));\n"
"            atomicAdd(&force[index1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.y*0x100000000)));\n"
"            atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[index2], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"            atomicAdd(&force[index2  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"            atomicAdd(&force[index2 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyTorsionRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int4* __restrict__ atomIndices,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            int atom_i = atomIndices[restraintIndex].x;\n"
"            int atom_j = atomIndices[restraintIndex].y;\n"
"            int atom_k = atomIndices[restraintIndex].z;\n"
"            int atom_l = atomIndices[restraintIndex].w;\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"\n"
"            // update forces\n"
"            float3 f_i = restForces[restraintIndex * 4 + 0];\n"
"            float3 f_j = restForces[restraintIndex * 4 + 1];\n"
"            float3 f_k = restForces[restraintIndex * 4 + 2];\n"
"            float3 f_l = restForces[restraintIndex * 4 + 3];\n"
"\n"
"            atomicAdd(&force[atom_i],                        static_cast<unsigned long long>((long long) (f_i.x*0x100000000)));\n"
"            atomicAdd(&force[atom_i  + PADDED_NUM_ATOMS],    static_cast<unsigned long long>((long long) (f_i.y*0x100000000)));\n"
"            atomicAdd(&force[atom_i + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f_i.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[atom_j],                        static_cast<unsigned long long>((long long) (f_j.x*0x100000000)));\n"
"            atomicAdd(&force[atom_j  + PADDED_NUM_ATOMS],    static_cast<unsigned long long>((long long) (f_j.y*0x100000000)));\n"
"            atomicAdd(&force[atom_j + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f_j.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[atom_k],                        static_cast<unsigned long long>((long long) (f_k.x*0x100000000)));\n"
"            atomicAdd(&force[atom_k  + PADDED_NUM_ATOMS],    static_cast<unsigned long long>((long long) (f_k.y*0x100000000)));\n"
"            atomicAdd(&force[atom_k + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f_k.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[atom_l],                        static_cast<unsigned long long>((long long) (f_l.x*0x100000000)));\n"
"            atomicAdd(&force[atom_l  + PADDED_NUM_ATOMS],    static_cast<unsigned long long>((long long) (f_l.y*0x100000000)));\n"
"            atomicAdd(&force[atom_l + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f_l.z*0x100000000)));\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyDistProfileRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int2* __restrict__ atomIndices,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            int index1 = atomIndices[restraintIndex].x;\n"
"            int index2 = atomIndices[restraintIndex].y;\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"            float3 f = restForces[restraintIndex];\n"
"\n"
"            atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (-f.x*0x100000000)));\n"
"            atomicAdd(&force[index1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.y*0x100000000)));\n"
"            atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[index2], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"            atomicAdd(&force[index2  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"            atomicAdd(&force[index2 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyTorsProfileRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int4* __restrict__ atomIndices0,\n"
"                                const int4* __restrict__ atomIndices1,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            // update energy\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"\n"
"            // update phi\n"
"            int phi_atom_i = atomIndices0[restraintIndex].x;\n"
"            int phi_atom_j = atomIndices0[restraintIndex].y;\n"
"            int phi_atom_k = atomIndices0[restraintIndex].z;\n"
"            int phi_atom_l = atomIndices0[restraintIndex].w;\n"
"\n"
"            // update forces\n"
"            float3 phi_f_i = restForces[restraintIndex * 8 + 0];\n"
"            float3 phi_f_j = restForces[restraintIndex * 8 + 1];\n"
"            float3 phi_f_k = restForces[restraintIndex * 8 + 2];\n"
"            float3 phi_f_l = restForces[restraintIndex * 8 + 3];\n"
"\n"
"            atomicAdd(&force[phi_atom_i],                        static_cast<unsigned long long>((long long) (phi_f_i.x*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_i + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (phi_f_i.y*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_i + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (phi_f_i.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[phi_atom_j],                        static_cast<unsigned long long>((long long) (phi_f_j.x*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_j + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (phi_f_j.y*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_j + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (phi_f_j.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[phi_atom_k],                        static_cast<unsigned long long>((long long) (phi_f_k.x*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_k + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (phi_f_k.y*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_k + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (phi_f_k.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[phi_atom_l],                        static_cast<unsigned long long>((long long) (phi_f_l.x*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_l + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (phi_f_l.y*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_l + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (phi_f_l.z*0x100000000)));\n"
"\n"
"            // update psi\n"
"            int psi_atom_i = atomIndices1[restraintIndex].x;\n"
"            int psi_atom_j = atomIndices1[restraintIndex].y;\n"
"            int psi_atom_k = atomIndices1[restraintIndex].z;\n"
"            int psi_atom_l = atomIndices1[restraintIndex].w;\n"
"\n"
"            // update forces\n"
"            float3 psi_f_i = restForces[restraintIndex * 8 + 4];\n"
"            float3 psi_f_j = restForces[restraintIndex * 8 + 5];\n"
"            float3 psi_f_k = restForces[restraintIndex * 8 + 6];\n"
"            float3 psi_f_l = restForces[restraintIndex * 8 + 7];\n"
"\n"
"            atomicAdd(&force[psi_atom_i],                        static_cast<unsigned long long>((long long) (psi_f_i.x*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_i + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (psi_f_i.y*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_i + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (psi_f_i.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[psi_atom_j],                        static_cast<unsigned long long>((long long) (psi_f_j.x*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_j + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (psi_f_j.y*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_j + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (psi_f_j.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[psi_atom_k],                        static_cast<unsigned long long>((long long) (psi_f_k.x*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_k + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (psi_f_k.y*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_k + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (psi_f_k.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[psi_atom_l],                        static_cast<unsigned long long>((long long) (psi_f_l.x*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_l + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (psi_f_l.y*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_l + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (psi_f_l.z*0x100000000)));\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"extern \"C\" __global__ void applyGMMRest(unsigned long long * __restrict__ force,\n"
"                                        mixed* __restrict__ energyBuffer,\n"
"                                        const int numRestraints,\n"
"                                        const int4* __restrict params,\n"
"                                        const float* __restrict__ globalEnergies,\n"
"                                        const float* __restrict__ globalActive,\n"
"                                        const int2* __restrict__ offsets,\n"
"                                        const int* __restrict__ atomIndices,\n"
"                                        const float3* __restrict__ restForces) {\n"
"\n"
"    int tid = threadIdx.x;\n"
"    int warp = tid / 32;\n"
"    int lane = tid % 32;\n"
"\n"
"    for (int index=16*blockIdx.x + warp; index<numRestraints; index+=16*gridDim.x) {\n"
"        int nPairs = params[index].x;\n"
"        int globalIndex = params[index].z;\n"
"        int atomBlockOffset = offsets[index].x;\n"
"\n"
"        if (globalActive[globalIndex]) {\n"
"            // add the forces\n"
"            if (lane < nPairs) {\n"
"                float3 f = restForces[atomBlockOffset + lane];\n"
"                int atomIndex1 = atomIndices[atomBlockOffset + 2 * lane];\n"
"                int atomIndex2 = atomIndices[atomBlockOffset + 2 * lane + 1];\n"
"\n"
"                atomicAdd(&force[atomIndex1], static_cast<unsigned long long>((long long) (-f.x*0x100000000)));\n"
"                atomicAdd(&force[atomIndex1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.y*0x100000000)));\n"
"                atomicAdd(&force[atomIndex1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.z*0x100000000)));\n"
"\n"
"                atomicAdd(&force[atomIndex2], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"                atomicAdd(&force[atomIndex2  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"                atomicAdd(&force[atomIndex2 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"            }\n"
"\n"
"            // add the energy\n"
"            if (lane == 0) {\n"
"                energyBuffer[tid] += globalEnergies[globalIndex];\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"extern \"C\" __global__ void applyEmapRest(unsigned long long * __restrict__ force,\n"
"                                         mixed* __restrict__ energyBuffer,\n"
"                                         const int* __restrict__ atomIndices,\n"
"                                         const int* __restrict__ globalIndices,\n"
"                                         const float* __restrict__ globalEnergies,\n"
"                                         const float* __restrict__ globalActive,\n"
"                                         const float3* __restrict__ restForces,\n"
"                                         const int numEmapRestraints,\n"
"                                         const int numEmapAtoms) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numEmapAtoms; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int index1 = atomIndices[restraintIndex];\n"
"        float3 f = restForces[restraintIndex];\n"
"\n"
"\n"
"        atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"        atomicAdd(&force[index1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"        atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"        }\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numEmapRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        energyBuffer[threadIndex] += globalEnergies[globalIndex];\n"
"        }\n"
"    \n"
"    // }\n"
"    // energyBuffer[threadIndex] += energyAccum;\n"
"    // printf(\"energyAccum: %f \\n\",energyAccum);\n"
"}\n"
"";
const string CudaMeldKernelSources::vectorOps = "/**\n"
" * This file defines vector operations to simplify code elsewhere.\n"
"*/\n"
"\n"
"// Versions of make_x() that take a single value and set all components to that.\n"
"\n"
"inline __device__ int2 make_int2(int a) {\n"
"    return make_int2(a, a);\n"
"}\n"
"\n"
"inline __device__ int3 make_int3(int a) {\n"
"    return make_int3(a, a, a);\n"
"}\n"
"\n"
"inline __device__ int4 make_int4(int a) {\n"
"    return make_int4(a, a, a, a);\n"
"}\n"
"\n"
"inline __device__ float2 make_float2(float a) {\n"
"    return make_float2(a, a);\n"
"}\n"
"\n"
"inline __device__ float3 make_float3(float a) {\n"
"    return make_float3(a, a, a);\n"
"}\n"
"\n"
"inline __device__ float4 make_float4(float a) {\n"
"    return make_float4(a, a, a, a);\n"
"}\n"
"\n"
"inline __device__ double2 make_double2(double a) {\n"
"    return make_double2(a, a);\n"
"}\n"
"\n"
"inline __device__ double3 make_double3(double a) {\n"
"    return make_double3(a, a, a);\n"
"}\n"
"\n"
"inline __device__ double4 make_double4(double a) {\n"
"    return make_double4(a, a, a, a);\n"
"}\n"
"\n"
"// Negate a vector.\n"
"\n"
"inline __device__ int2 operator-(int2 a) {\n"
"    return make_int2(-a.x, -a.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator-(int3 a) {\n"
"    return make_int3(-a.x, -a.y, -a.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator-(int4 a) {\n"
"    return make_int4(-a.x, -a.y, -a.z, -a.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator-(float2 a) {\n"
"    return make_float2(-a.x, -a.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator-(float3 a) {\n"
"    return make_float3(-a.x, -a.y, -a.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator-(float4 a) {\n"
"    return make_float4(-a.x, -a.y, -a.z, -a.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator-(double2 a) {\n"
"    return make_double2(-a.x, -a.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator-(double3 a) {\n"
"    return make_double3(-a.x, -a.y, -a.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator-(double4 a) {\n"
"    return make_double4(-a.x, -a.y, -a.z, -a.w);\n"
"}\n"
"\n"
"// Add two vectors.\n"
"\n"
"inline __device__ int2 operator+(int2 a, int2 b) {\n"
"    return make_int2(a.x+b.x, a.y+b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator+(int3 a, int3 b) {\n"
"    return make_int3(a.x+b.x, a.y+b.y, a.z+b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator+(int4 a, int4 b) {\n"
"    return make_int4(a.x+b.x, a.y+b.y, a.z+b.z, a.w+b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator+(float2 a, float2 b) {\n"
"    return make_float2(a.x+b.x, a.y+b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator+(float3 a, float3 b) {\n"
"    return make_float3(a.x+b.x, a.y+b.y, a.z+b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator+(float4 a, float4 b) {\n"
"    return make_float4(a.x+b.x, a.y+b.y, a.z+b.z, a.w+b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator+(double2 a, double2 b) {\n"
"    return make_double2(a.x+b.x, a.y+b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator+(double3 a, double3 b) {\n"
"    return make_double3(a.x+b.x, a.y+b.y, a.z+b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator+(double4 a, double4 b) {\n"
"    return make_double4(a.x+b.x, a.y+b.y, a.z+b.z, a.w+b.w);\n"
"}\n"
"\n"
"// Subtract two vectors.\n"
"\n"
"inline __device__ int2 operator-(int2 a, int2 b) {\n"
"    return make_int2(a.x-b.x, a.y-b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator-(int3 a, int3 b) {\n"
"    return make_int3(a.x-b.x, a.y-b.y, a.z-b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator-(int4 a, int4 b) {\n"
"    return make_int4(a.x-b.x, a.y-b.y, a.z-b.z, a.w-b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator-(float2 a, float2 b) {\n"
"    return make_float2(a.x-b.x, a.y-b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator-(float3 a, float3 b) {\n"
"    return make_float3(a.x-b.x, a.y-b.y, a.z-b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator-(float4 a, float4 b) {\n"
"    return make_float4(a.x-b.x, a.y-b.y, a.z-b.z, a.w-b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator-(double2 a, double2 b) {\n"
"    return make_double2(a.x-b.x, a.y-b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator-(double3 a, double3 b) {\n"
"    return make_double3(a.x-b.x, a.y-b.y, a.z-b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator-(double4 a, double4 b) {\n"
"    return make_double4(a.x-b.x, a.y-b.y, a.z-b.z, a.w-b.w);\n"
"}\n"
"\n"
"// Multiply two vectors.\n"
"\n"
"inline __device__ int2 operator*(int2 a, int2 b) {\n"
"    return make_int2(a.x*b.x, a.y*b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator*(int3 a, int3 b) {\n"
"    return make_int3(a.x*b.x, a.y*b.y, a.z*b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator*(int4 a, int4 b) {\n"
"    return make_int4(a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator*(float2 a, float2 b) {\n"
"    return make_float2(a.x*b.x, a.y*b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator*(float3 a, float3 b) {\n"
"    return make_float3(a.x*b.x, a.y*b.y, a.z*b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator*(float4 a, float4 b) {\n"
"    return make_float4(a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator*(double2 a, double2 b) {\n"
"    return make_double2(a.x*b.x, a.y*b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator*(double3 a, double3 b) {\n"
"    return make_double3(a.x*b.x, a.y*b.y, a.z*b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator*(double4 a, double4 b) {\n"
"    return make_double4(a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w);\n"
"}\n"
"\n"
"// Divide two vectors.\n"
"\n"
"inline __device__ int2 operator/(int2 a, int2 b) {\n"
"    return make_int2(a.x/b.x, a.y/b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator/(int3 a, int3 b) {\n"
"    return make_int3(a.x/b.x, a.y/b.y, a.z/b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator/(int4 a, int4 b) {\n"
"    return make_int4(a.x/b.x, a.y/b.y, a.z/b.z, a.w/b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator/(float2 a, float2 b) {\n"
"    return make_float2(a.x/b.x, a.y/b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator/(float3 a, float3 b) {\n"
"    return make_float3(a.x/b.x, a.y/b.y, a.z/b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator/(float4 a, float4 b) {\n"
"    return make_float4(a.x/b.x, a.y/b.y, a.z/b.z, a.w/b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator/(double2 a, double2 b) {\n"
"    return make_double2(a.x/b.x, a.y/b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator/(double3 a, double3 b) {\n"
"    return make_double3(a.x/b.x, a.y/b.y, a.z/b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator/(double4 a, double4 b) {\n"
"    return make_double4(a.x/b.x, a.y/b.y, a.z/b.z, a.w/b.w);\n"
"}\n"
"\n"
"// += operator\n"
"\n"
"inline __device__ void operator+=(int2& a, int2 b) {\n"
"    a.x += b.x; a.y += b.y;\n"
"}\n"
"\n"
"inline __device__ void operator+=(int3& a, int3 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z;\n"
"}\n"
"\n"
"inline __device__ void operator+=(int4& a, int4 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z; a.w += b.w;\n"
"}\n"
"\n"
"inline __device__ void operator+=(float2& a, float2 b) {\n"
"    a.x += b.x; a.y += b.y;\n"
"}\n"
"\n"
"inline __device__ void operator+=(float3& a, float3 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z;\n"
"}\n"
"\n"
"inline __device__ void operator+=(float4& a, float4 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z; a.w += b.w;\n"
"}\n"
"\n"
"inline __device__ void operator+=(double2& a, double2 b) {\n"
"    a.x += b.x; a.y += b.y;\n"
"}\n"
"\n"
"inline __device__ void operator+=(double3& a, double3 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z;\n"
"}\n"
"\n"
"inline __device__ void operator+=(double4& a, double4 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z; a.w += b.w;\n"
"}\n"
"\n"
"// -= operator\n"
"\n"
"inline __device__ void operator-=(int2& a, int2 b) {\n"
"    a.x -= b.x; a.y -= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator-=(int3& a, int3 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator-=(int4& a, int4 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z; a.w -= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator-=(float2& a, float2 b) {\n"
"    a.x -= b.x; a.y -= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator-=(float3& a, float3 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator-=(float4& a, float4 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z; a.w -= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator-=(double2& a, double2 b) {\n"
"    a.x -= b.x; a.y -= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator-=(double3& a, double3 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator-=(double4& a, double4 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z; a.w -= b.w;\n"
"}\n"
"\n"
"// *= operator\n"
"\n"
"inline __device__ void operator*=(int2& a, int2 b) {\n"
"    a.x *= b.x; a.y *= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator*=(int3& a, int3 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator*=(int4& a, int4 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z; a.w *= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float2& a, float2 b) {\n"
"    a.x *= b.x; a.y *= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float3& a, float3 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float4& a, float4 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z; a.w *= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double2& a, double2 b) {\n"
"    a.x *= b.x; a.y *= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double3& a, double3 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double4& a, double4 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z; a.w *= b.w;\n"
"}\n"
"\n"
"// /= operator\n"
"\n"
"inline __device__ void operator/=(int2& a, int2 b) {\n"
"    a.x /= b.x; a.y /= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator/=(int3& a, int3 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator/=(int4& a, int4 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z; a.w /= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator/=(float2& a, float2 b) {\n"
"    a.x /= b.x; a.y /= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator/=(float3& a, float3 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator/=(float4& a, float4 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z; a.w /= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator/=(double2& a, double2 b) {\n"
"    a.x /= b.x; a.y /= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator/=(double3& a, double3 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator/=(double4& a, double4 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z; a.w /= b.w;\n"
"}\n"
"\n"
"// Multiply a vector by a constant.\n"
"\n"
"inline __device__ int2 operator*(int2 a, int b) {\n"
"    return make_int2(a.x*b, a.y*b);\n"
"}\n"
"\n"
"inline __device__ int3 operator*(int3 a, int b) {\n"
"    return make_int3(a.x*b, a.y*b, a.z*b);\n"
"}\n"
"\n"
"inline __device__ int4 operator*(int4 a, int b) {\n"
"    return make_int4(a.x*b, a.y*b, a.z*b, a.w*b);\n"
"}\n"
"\n"
"inline __device__ int2 operator*(int a, int2 b) {\n"
"    return make_int2(a*b.x, a*b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator*(int a, int3 b) {\n"
"    return make_int3(a*b.x, a*b.y, a*b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator*(int a, int4 b) {\n"
"    return make_int4(a*b.x, a*b.y, a*b.z, a*b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator*(float2 a, float b) {\n"
"    return make_float2(a.x*b, a.y*b);\n"
"}\n"
"\n"
"inline __device__ float3 operator*(float3 a, float b) {\n"
"    return make_float3(a.x*b, a.y*b, a.z*b);\n"
"}\n"
"\n"
"inline __device__ float4 operator*(float4 a, float b) {\n"
"    return make_float4(a.x*b, a.y*b, a.z*b, a.w*b);\n"
"}\n"
"\n"
"inline __device__ float2 operator*(float a, float2 b) {\n"
"    return make_float2(a*b.x, a*b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator*(float a, float3 b) {\n"
"    return make_float3(a*b.x, a*b.y, a*b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator*(float a, float4 b) {\n"
"    return make_float4(a*b.x, a*b.y, a*b.z, a*b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator*(double2 a, double b) {\n"
"    return make_double2(a.x*b, a.y*b);\n"
"}\n"
"\n"
"inline __device__ double3 operator*(double3 a, double b) {\n"
"    return make_double3(a.x*b, a.y*b, a.z*b);\n"
"}\n"
"\n"
"inline __device__ double4 operator*(double4 a, double b) {\n"
"    return make_double4(a.x*b, a.y*b, a.z*b, a.w*b);\n"
"}\n"
"\n"
"inline __device__ double2 operator*(double a, double2 b) {\n"
"    return make_double2(a*b.x, a*b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator*(double a, double3 b) {\n"
"    return make_double3(a*b.x, a*b.y, a*b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator*(double a, double4 b) {\n"
"    return make_double4(a*b.x, a*b.y, a*b.z, a*b.w);\n"
"}\n"
"\n"
"// Divide a vector by a constant.\n"
"\n"
"inline __device__ int2 operator/(int2 a, int b) {\n"
"    return make_int2(a.x/b, a.y/b);\n"
"}\n"
"\n"
"inline __device__ int3 operator/(int3 a, int b) {\n"
"    return make_int3(a.x/b, a.y/b, a.z/b);\n"
"}\n"
"\n"
"inline __device__ int4 operator/(int4 a, int b) {\n"
"    return make_int4(a.x/b, a.y/b, a.z/b, a.w/b);\n"
"}\n"
"\n"
"inline __device__ float2 operator/(float2 a, float b) {\n"
"    float scale = 1.0f/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ float3 operator/(float3 a, float b) {\n"
"    float scale = 1.0f/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ float4 operator/(float4 a, float b) {\n"
"    float scale = 1.0f/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ double2 operator/(double2 a, double b) {\n"
"    double scale = 1.0/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ double3 operator/(double3 a, double b) {\n"
"    double scale = 1.0/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ double4 operator/(double4 a, double b) {\n"
"    double scale = 1.0/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"// *= operator (multiply vector by constant)\n"
"\n"
"inline __device__ void operator*=(int2& a, int b) {\n"
"    a.x *= b; a.y *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(int3& a, int b) {\n"
"    a.x *= b; a.y *= b; a.z *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(int4& a, int b) {\n"
"    a.x *= b; a.y *= b; a.z *= b; a.w *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float2& a, float b) {\n"
"    a.x *= b; a.y *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float3& a, float b) {\n"
"    a.x *= b; a.y *= b; a.z *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float4& a, float b) {\n"
"    a.x *= b; a.y *= b; a.z *= b; a.w *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double2& a, double b) {\n"
"    a.x *= b; a.y *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double3& a, double b) {\n"
"    a.x *= b; a.y *= b; a.z *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double4& a, double b) {\n"
"    a.x *= b; a.y *= b; a.z *= b; a.w *= b;\n"
"}\n"
"\n"
"// Dot product\n"
"\n"
"inline __device__ float dot(float3 a, float3 b) {\n"
"    return a.x*b.x+a.y*b.y+a.z*b.z;\n"
"}\n"
"\n"
"inline __device__ double dot(double3 a, double3 b) {\n"
"    return a.x*b.x+a.y*b.y+a.z*b.z;\n"
"}\n"
"\n"
"// Cross product\n"
"\n"
"inline __device__ float3 cross(float3 a, float3 b) {\n"
"    return make_float3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n"
"}\n"
"\n"
"inline __device__ float3 cross(float4 a, float4 b) {\n"
"    return make_float3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n"
"}\n"
"\n"
"inline __device__ double3 cross(double3 a, double3 b) {\n"
"    return make_double3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n"
"}\n"
"\n"
"inline __device__ double3 cross(double4 a, double4 b) {\n"
"    return make_double3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n"
"}\n"
"\n"
"// Normalize a vector\n"
"\n"
"inline __device__ float2 normalize(float2 a) {\n"
"    return a*rsqrtf(a.x*a.x+a.y*a.y);\n"
"}\n"
"\n"
"inline __device__ float3 normalize(float3 a) {\n"
"    return a*rsqrtf(a.x*a.x+a.y*a.y+a.z*a.z);\n"
"}\n"
"\n"
"inline __device__ float4 normalize(float4 a) {\n"
"    return a*rsqrtf(a.x*a.x+a.y*a.y+a.z*a.z+a.w*a.w);\n"
"}\n"
"\n"
"inline __device__ double2 normalize(double2 a) {\n"
"    return a*rsqrt(a.x*a.x+a.y*a.y);\n"
"}\n"
"\n"
"inline __device__ double3 normalize(double3 a) {\n"
"    return a*rsqrt(a.x*a.x+a.y*a.y+a.z*a.z);\n"
"}\n"
"\n"
"inline __device__ double4 normalize(double4 a) {\n"
"    return a*rsqrt(a.x*a.x+a.y*a.y+a.z*a.z+a.w*a.w);\n"
"}\n"
"\n"
"// Strip off the fourth component of a vector.\n"
"\n"
"inline __device__ float3 trimTo3(float4 v) {\n"
"    return make_float3(v.x, v.y, v.z);\n"
"}\n"
"\n"
"inline __device__ double3 trimTo3(double4 v) {\n"
"    return make_double3(v.x, v.y, v.z);\n"
"}\n"
"";
