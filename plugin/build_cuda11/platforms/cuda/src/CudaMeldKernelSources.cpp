/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2012 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "CudaMeldKernelSources.h"

using namespace MeldPlugin;
using namespace std;

const string CudaMeldKernelSources::computeMeld = "/*\n"
"   Copyright 2015 by Justin MacCallum, Alberto Perez, Ken Dill\n"
"   All rights reserved\n"
"*/\n"
"\n"
"#include <cub/cub.cuh>\n"
"#include <cfloat>\n"
"\n"
"__device__ void computeTorsionAngle(const real4* __restrict__ posq, int atom_i, int atom_j, int atom_k, int atom_l,\n"
"        float3& r_ij, float3& r_kj, float3& r_kl, float3& m, float3& n,\n"
"        float& len_r_kj, float& len_m, float& len_n, float& phi) {\n"
"    // compute vectors\n"
"    r_ij = trimTo3(posq[atom_j] - posq[atom_i]);\n"
"    r_kj = trimTo3(posq[atom_j] - posq[atom_k]);\n"
"    r_kl = trimTo3(posq[atom_l] - posq[atom_k]);\n"
"\n"
"    // compute normal vectors\n"
"    m = cross(r_ij, r_kj);\n"
"    n = cross(r_kj, r_kl);\n"
"\n"
"    // compute lengths\n"
"    len_r_kj = sqrt(dot(r_kj, r_kj));\n"
"    len_m = sqrt(dot(m, m));\n"
"    len_n = sqrt(dot(n, n));\n"
"\n"
"    // compute angle phi\n"
"    float x = dot(m / len_m, n / len_n);\n"
"    float y = dot(cross(m / len_m, r_kj / len_r_kj), n / len_n);\n"
"    phi = atan2(y, x) * 180. / 3.141592654;\n"
"}\n"
"\n"
"\n"
"__device__ void computeTorsionForce(const float dEdPhi, const float3& r_ij, const float3& r_kj, const float3& r_kl,\n"
"        const float3& m, const float3& n, const float len_r_kj, const float len_m, const float len_n,\n"
"        float3& F_i, float3& F_j, float3& F_k, float3& F_l) {\n"
"    F_i = -180. / 3.141592654 * dEdPhi * len_r_kj * m / (len_m * len_m);\n"
"    F_l = 180. / 3.141592654 * dEdPhi * len_r_kj * n / (len_n * len_n);\n"
"    F_j = -F_i + dot(r_ij, r_kj) / (len_r_kj * len_r_kj) * F_i - dot(r_kl, r_kj) / (len_r_kj * len_r_kj) * F_l;\n"
"    F_k = -F_l - dot(r_ij, r_kj) / (len_r_kj * len_r_kj) * F_i + dot(r_kl, r_kj) / (len_r_kj * len_r_kj) * F_l;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeDistRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int2* __restrict__ atomIndices,       // pair of atom indices\n"
"                            const float4* __restrict__ distanceBounds,  // r1, r2, r3, r4\n"
"                            const float* __restrict__ forceConstants,   // k\n"
"                            int* __restrict__ indexToGlobal,            // array of indices into global arrays\n"
"                            float* __restrict__ energies,               // global array of restraint energies\n"
"                            float3* __restrict__ forceBuffer,           // temporary buffer to hold the force\n"
"                            const int numRestraints) {\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=blockDim.x*gridDim.x) {\n"
"        // get my global index\n"
"        const int globalIndex = indexToGlobal[index];\n"
"\n"
"        // get the distances\n"
"        const float r1 = distanceBounds[index].x;\n"
"        const float r2 = distanceBounds[index].y;\n"
"        const float r3 = distanceBounds[index].z;\n"
"        const float r4 = distanceBounds[index].w;\n"
"\n"
"        // get the force constant\n"
"        const float k = forceConstants[index];\n"
"\n"
"        // get atom indices and compute distance\n"
"        int atomIndexA = atomIndices[index].x;\n"
"        int atomIndexB = atomIndices[index].y;\n"
"\n"
"        if (atomIndexA == -1) {\n"
"            // If the first index is -1, this restraint\n"
"            // is marked as being not mapped.  We set the force to\n"
"            // zero. We set the energy to FLT_MAX, so that this\n"
"            // restraint will not be selected during sorting when\n"
"            // the groups are evaluated. Later, when we apply\n"
"            // restraints, this restraint will be applied with\n"
"            // an energy of zero should it be selected.\n"
"            float3 f;\n"
"            f.x = 0.0;\n"
"            f.y = 0.0;\n"
"            f.z = 0.0;\n"
"            forceBuffer[index] = f;\n"
"            energies[globalIndex] = FLT_MAX;\n"
"        } else {\n"
"            real4 delta = posq[atomIndexA] - posq[atomIndexB];\n"
"            real distSquared = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"            real r = SQRT(distSquared);\n"
"\n"
"            // compute force and energy\n"
"            float energy = 0.0;\n"
"            float dEdR = 0.0;\n"
"            float diff = 0.0;\n"
"            float diff2 = 0.0;\n"
"            float3 f;\n"
"\n"
"            if(r < r1) {\n"
"                energy = k * (r - r1) * (r1 - r2) + 0.5 * k * (r1 - r2) * (r1 - r2);\n"
"                dEdR = k * (r1 - r2);\n"
"            }\n"
"            else if(r < r2) {\n"
"                diff = r - r2;\n"
"                diff2 = diff * diff;\n"
"                energy = 0.5 * k * diff2;\n"
"                dEdR = k * diff;\n"
"            }\n"
"            else if(r < r3) {\n"
"                dEdR = 0.0;\n"
"                energy = 0.0;\n"
"            }\n"
"            else if(r < r4) {\n"
"                diff = r - r3;\n"
"                diff2 = diff * diff;\n"
"                energy = 0.5 * k * diff2;\n"
"                dEdR = k * diff;\n"
"            }\n"
"            else {\n"
"                energy = k * (r - r4) * (r4 - r3) + 0.5 * k * (r4 - r3) * (r4 - r3);\n"
"                dEdR = k * (r4 - r3);\n"
"            }\n"
"\n"
"            // store force into local buffer\n"
"            if (r > 0) {\n"
"                f.x = delta.x * dEdR / r;\n"
"                f.y = delta.y * dEdR / r;\n"
"                f.z = delta.z * dEdR / r;\n"
"            } else {\n"
"                f.x = 0.0;\n"
"                f.y = 0.0;\n"
"                f.z = 0.0;\n"
"            }\n"
"            forceBuffer[index] = f;\n"
"\n"
"            // store energy into global buffer\n"
"            energies[globalIndex] = energy;\n"
"            // printf(\"forces: %f, %f, %f \\n\", f.x, f.y, f.z);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeHyperbolicDistRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int2* __restrict__ atomIndices,       // pair of atom indices\n"
"                            const float4* __restrict__ distanceBounds,  // r1, r2, r3, r4\n"
"                            const float4* __restrict__ params,          // k1, k2, a, b\n"
"                            int* __restrict__ indexToGlobal,            // array of indices into global arrays\n"
"                            float* __restrict__ energies,               // global array of restraint energies\n"
"                            float3* __restrict__ forceBuffer,           // temporary buffer to hold the force\n"
"                            const int numRestraints) {\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=blockDim.x*gridDim.x) {\n"
"        // get my global index\n"
"        const int globalIndex = indexToGlobal[index];\n"
"\n"
"        // get the distances\n"
"        const float r1 = distanceBounds[index].x;\n"
"        const float r2 = distanceBounds[index].y;\n"
"        const float r3 = distanceBounds[index].z;\n"
"        const float r4 = distanceBounds[index].w;\n"
"\n"
"        // get the parameters\n"
"        const float k1 = params[index].x;\n"
"        const float k2 = params[index].y;\n"
"        const float a = params[index].z;\n"
"        const float b = params[index].w;\n"
"\n"
"        // get atom indices and compute distance\n"
"        int atomIndexA = atomIndices[index].x;\n"
"        int atomIndexB = atomIndices[index].y;\n"
"        real4 delta = posq[atomIndexA] - posq[atomIndexB];\n"
"        real distSquared = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"        real r = SQRT(distSquared);\n"
"\n"
"        // compute force and energy\n"
"        float energy = 0.0;\n"
"        float dEdR = 0.0;\n"
"        float diff = 0.0;\n"
"        float diff2 = 0.0;\n"
"        float3 f;\n"
"\n"
"        if(r < r1) {\n"
"            energy = k1 * (r - r1) * (r1 - r2) + 0.5 * k1 * (r1 - r2) * (r1 - r2);\n"
"            dEdR = k1 * (r1 - r2);\n"
"        }\n"
"        else if(r < r2) {\n"
"            diff = r - r2;\n"
"            diff2 = diff * diff;\n"
"            energy = 0.5 * k1 * diff2;\n"
"            dEdR = k1 * diff;\n"
"        }\n"
"        else if(r < r3) {\n"
"            dEdR = 0.0;\n"
"            energy = 0.0;\n"
"        }\n"
"        else if(r < r4) {\n"
"            diff = r - r3;\n"
"            diff2 = diff * diff;\n"
"            energy = 0.5 * k2 * diff2;\n"
"            dEdR = k2 * diff;\n"
"        }\n"
"        else {\n"
"            energy = 0.5 * k2 * (b / (r - r3) + a);\n"
"            dEdR = -0.5 * b * k2 / (r - r3) / (r - r3);\n"
"        }\n"
"\n"
"        // store force into local buffer\n"
"        if (r > 0) {\n"
"            f.x = delta.x * dEdR / r;\n"
"            f.y = delta.y * dEdR / r;\n"
"            f.z = delta.z * dEdR / r;\n"
"        } else {\n"
"            f.x = 0.0;\n"
"            f.y = 0.0;\n"
"            f.z = 0.0;\n"
"        }\n"
"        forceBuffer[index] = f;\n"
"\n"
"        // store energy into global buffer\n"
"        energies[globalIndex] = energy;\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeTorsionRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int4* __restrict__ atomIndices,       // indices of atom_{i,j,k,l}\n"
"                            const float3* __restrict__ params,          // phi, deltaPhi, forceConstant\n"
"                            int* __restrict__ indexToGlobal,            // array of indices into global arrays\n"
"                            float* __restrict__ energies,               // global array of restraint energies\n"
"                            float3* __restrict__ forceBuffer,           // temporary buffer to hold the force\n"
"                                                                        // forceBuffer[index*4] -> atom_i\n"
"                                                                        // forceBuffer[index*4 + 3] -> atom_l\n"
"                            const int numRestraints) {\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=gridDim.x*blockDim.x) {\n"
"        // get my global index\n"
"        int globalIndex = indexToGlobal[index];\n"
"\n"
"        // get the atom indices\n"
"        int4 indices = atomIndices[index];\n"
"        int atom_i = indices.x;\n"
"        int atom_j = indices.y;\n"
"        int atom_k = indices.z;\n"
"        int atom_l = indices.w;\n"
"\n"
"        // compute the angle and related quantities\n"
"        float3 r_ij, r_kj, r_kl;\n"
"        float3 m, n;\n"
"        float len_r_kj;\n"
"        float len_m;\n"
"        float len_n;\n"
"        float phi;\n"
"        computeTorsionAngle(posq, atom_i, atom_j, atom_k, atom_l,\n"
"                r_ij, r_kj, r_kl, m, n, len_r_kj, len_m, len_n,  phi);\n"
"\n"
"        // compute E and dE/dphi\n"
"        float phiEquil = params[index].x;\n"
"        float phiDelta = params[index].y;\n"
"        float forceConst = params[index].z;\n"
"\n"
"        float phiDiff = phi - phiEquil;\n"
"        if (phiDiff < -180.) {\n"
"            phiDiff += 360.;\n"
"        } else if (phiDiff > 180.) {\n"
"            phiDiff -= 360.;\n"
"        }\n"
"\n"
"        float energy = 0.0;\n"
"        float dEdPhi = 0.0;\n"
"        if (phiDiff < -phiDelta) {\n"
"            energy = 0.5 * forceConst * (phiDiff + phiDelta) * (phiDiff + phiDelta);\n"
"            dEdPhi = forceConst * (phiDiff + phiDelta);\n"
"        }\n"
"        else if(phiDiff > phiDelta) {\n"
"            energy = 0.5 * forceConst * (phiDiff - phiDelta) * (phiDiff - phiDelta);\n"
"            dEdPhi = forceConst * (phiDiff - phiDelta);\n"
"        }\n"
"        else{\n"
"            energy = 0.0;\n"
"            dEdPhi = 0.0;\n"
"        }\n"
"\n"
"        energies[globalIndex] = energy;\n"
"\n"
"        computeTorsionForce(dEdPhi, r_ij, r_kj, r_kl, m, n, len_r_kj, len_m, len_n,\n"
"                forceBuffer[4 * index + 0], forceBuffer[4 * index + 1],\n"
"                forceBuffer[4 * index + 2], forceBuffer[4 * index + 3]);\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeDistProfileRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int2* __restrict__ atomIndices,       // pair of atom indices\n"
"                            const float2* __restrict__ distRanges,      // upper and lower bounds of spline\n"
"                            const int* __restrict__ nBins,              // number of bins\n"
"                            const float4* __restrict__ splineParams,    // a0, a1, a2, a3\n"
"                            const int2* __restrict__ paramBounds,       // upper and lower bounds for each spline\n"
"                            const float* __restrict__ scaleFactor,      // scale factor for energies and forces\n"
"                            const int* __restrict__ indexToGlobal,      // index of this restraint in the global array\n"
"                            float* __restrict__ restraintEnergies,      // global energy of each restraint\n"
"                            float3* __restrict__ restraintForce,        // cache the forces for application later\n"
"                            const int numRestraints ) {\n"
"\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=blockDim.x*gridDim.x) {\n"
"        // get my global index\n"
"        int globalIndex = indexToGlobal[index];\n"
"\n"
"        // get atom indices and compute distance\n"
"        int atomIndexA = atomIndices[index].x;\n"
"        int atomIndexB = atomIndices[index].y;\n"
"\n"
"        real4 delta = posq[atomIndexA] - posq[atomIndexB];\n"
"        real distSquared = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"        real r = SQRT(distSquared);\n"
"\n"
"        // compute bin\n"
"        int bin = (int)( floor((r - distRanges[index].x) / (distRanges[index].y - distRanges[index].x) * nBins[index]) );\n"
"\n"
"        // compute the force and energy\n"
"        float energy = 0.0;\n"
"        float dEdR = 0.0;\n"
"        float binWidth = (distRanges[index].y - distRanges[index].x) / nBins[index];\n"
"        if (bin < 0){\n"
"            energy = scaleFactor[index] * splineParams[paramBounds[index].x].x;\n"
"        }\n"
"        else if (bin >= nBins[index]) {\n"
"            energy = scaleFactor[index] * (splineParams[paramBounds[index].y - 1].x +\n"
"                                           splineParams[paramBounds[index].y - 1].y +\n"
"                                           splineParams[paramBounds[index].y - 1].z +\n"
"                                           splineParams[paramBounds[index].y - 1].w);\n"
"        }\n"
"        else {\n"
"            float t = (r - bin * binWidth + distRanges[index].x) / binWidth;\n"
"            float a0 = splineParams[ paramBounds[index].x + bin ].x;\n"
"            float a1 = splineParams[ paramBounds[index].x + bin ].y;\n"
"            float a2 = splineParams[ paramBounds[index].x + bin ].z;\n"
"            float a3 = splineParams[ paramBounds[index].x + bin ].w;\n"
"            energy = scaleFactor[index] * (a0 + a1 * t + a2 * t * t + a3 * t * t * t);\n"
"            dEdR = scaleFactor[index] * (a1 + 2.0 * a2 * t + 3.0 * a3 * t * t) / binWidth;\n"
"        }\n"
"\n"
"        // store force into local buffer\n"
"        float3 f;\n"
"        f.x = delta.x * dEdR / r;\n"
"        f.y = delta.y * dEdR / r;\n"
"        f.z = delta.z * dEdR / r;\n"
"        restraintForce[index] = f;\n"
"\n"
"        // store energy into global buffer\n"
"        restraintEnergies[globalIndex] = energy;\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeTorsProfileRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int4* __restrict__ atomIndices0,      // i,j,k,l for torsion 0\n"
"                            const int4* __restrict__ atomIndices1,      // i,j,k,l for torsion 1\n"
"                            const int* __restrict__ nBins,              // number of bins\n"
"                            const float4* __restrict__ params0,         // a0 - a3\n"
"                            const float4* __restrict__ params1,         // a4 - a7\n"
"                            const float4* __restrict__ params2,         // a8 - a11\n"
"                            const float4* __restrict__ params3,         // a12 - a15\n"
"                            const int2* __restrict__ paramBounds,       // upper and lower bounds for each spline\n"
"                            const float* __restrict__ scaleFactor,      // scale factor for energies and forces\n"
"                            const int* __restrict__ indexToGlobal,      // index of this restraint in the global array\n"
"                            float* __restrict__ restraintEnergies,      // global energy of each restraint\n"
"                            float3* __restrict__ forceBuffer,        // cache the forces for application later\n"
"                            const int numRestraints ) {\n"
"    for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=gridDim.x*blockDim.x) {\n"
"        // get my global index\n"
"        int globalIndex = indexToGlobal[index];\n"
"\n"
"        // compute phi\n"
"        int phi_atom_i = atomIndices0[index].x;\n"
"        int phi_atom_j = atomIndices0[index].y;\n"
"        int phi_atom_k = atomIndices0[index].z;\n"
"        int phi_atom_l = atomIndices0[index].w;\n"
"        float3 phi_r_ij, phi_r_kj, phi_r_kl;\n"
"        float3 phi_m, phi_n;\n"
"        float phi_len_r_kj;\n"
"        float phi_len_m;\n"
"        float phi_len_n;\n"
"        float phi;\n"
"        computeTorsionAngle(posq, phi_atom_i, phi_atom_j, phi_atom_k, phi_atom_l,\n"
"                phi_r_ij, phi_r_kj, phi_r_kl, phi_m, phi_n, phi_len_r_kj, phi_len_m, phi_len_n, phi);\n"
"\n"
"        // compute psi\n"
"        int psi_atom_i = atomIndices1[index].x;\n"
"        int psi_atom_j = atomIndices1[index].y;\n"
"        int psi_atom_k = atomIndices1[index].z;\n"
"        int psi_atom_l = atomIndices1[index].w;\n"
"        float3 psi_r_ij, psi_r_kj, psi_r_kl;\n"
"        float3 psi_m, psi_n;\n"
"        float psi_len_r_kj;\n"
"        float psi_len_m;\n"
"        float psi_len_n;\n"
"        float psi;\n"
"        computeTorsionAngle(posq, psi_atom_i, psi_atom_j, psi_atom_k, psi_atom_l,\n"
"                psi_r_ij, psi_r_kj, psi_r_kl, psi_m, psi_n, psi_len_r_kj, psi_len_m, psi_len_n, psi);\n"
"\n"
"        // compute bin indices\n"
"        int i = (int)(floor((phi + 180.)/360. * nBins[index]));\n"
"        int j = (int)(floor((psi + 180.)/360. * nBins[index]));\n"
"\n"
"        if (i >= nBins[index]) {\n"
"            i = 0;\n"
"            phi -= 360.;\n"
"        }\n"
"        if (i < 0) {\n"
"            i = nBins[index] - 1;\n"
"            phi += 360.;\n"
"        }\n"
"\n"
"        if (j >= nBins[index]) {\n"
"            j = 0;\n"
"            psi -= 360.;\n"
"        }\n"
"        if (j < 0) {\n"
"            j = nBins[index] - 1;\n"
"            psi += 360.;\n"
"        }\n"
"\n"
"        float delta = 360. / nBins[index];\n"
"        float u = (phi - i * delta + 180.) / delta;\n"
"        float v = (psi - j * delta + 180.) / delta;\n"
"\n"
"        int pi = paramBounds[index].x + i * nBins[index] + j;\n"
"\n"
"        float energy = params0[pi].x         + params0[pi].y * v       + params0[pi].z * v*v       + params0[pi].w * v*v*v +\n"
"                       params1[pi].x * u     + params1[pi].y * u*v     + params1[pi].z * u*v*v     + params1[pi].w * u*v*v*v +\n"
"                       params2[pi].x * u*u   + params2[pi].y * u*u*v   + params2[pi].z * u*u*v*v   + params2[pi].w * u*u*v*v*v +\n"
"                       params3[pi].x * u*u*u + params3[pi].y * u*u*u*v + params3[pi].z * u*u*u*v*v + params3[pi].w * u*u*u*v*v*v;\n"
"        energy = energy * scaleFactor[index];\n"
"\n"
"        float dEdPhi = params1[pi].x         + params1[pi].y * v     + params1[pi].z * v*v     + params1[pi].w * v*v*v +\n"
"                       params2[pi].x * 2*u   + params2[pi].y * 2*u*v   + params2[pi].z * 2*u*v*v   + params2[pi].w * 2*u*v*v*v +\n"
"                       params3[pi].x * 3*u*u + params3[pi].y * 3*u*u*v + params3[pi].z * 3*u*u*v*v + params3[pi].w * 3*u*u*v*v*v;\n"
"        dEdPhi = dEdPhi * scaleFactor[index] / delta;\n"
"\n"
"        float dEdPsi = params0[pi].y         + params0[pi].z * 2*v       + params0[pi].w * 3*v*v +\n"
"                       params1[pi].y * u     + params1[pi].z * u*2*v     + params1[pi].w * u*3*v*v +\n"
"                       params2[pi].y * u*u   + params2[pi].z * u*u*2*v   + params2[pi].w * u*u*3*v*v +\n"
"                       params3[pi].y * u*u*u + params3[pi].z * u*u*u*2*v + params3[pi].w * u*u*u*3*v*v;\n"
"        dEdPsi = dEdPsi * scaleFactor[index] / delta;\n"
"\n"
"        restraintEnergies[globalIndex] = energy;\n"
"\n"
"        computeTorsionForce(dEdPhi, phi_r_ij, phi_r_kj, phi_r_kl, phi_m, phi_n, phi_len_r_kj, phi_len_m, phi_len_n,\n"
"                forceBuffer[8 * index + 0], forceBuffer[8 * index + 1],\n"
"                forceBuffer[8 * index + 2], forceBuffer[8 * index + 3]);\n"
"        computeTorsionForce(dEdPsi, psi_r_ij, psi_r_kj, psi_r_kl, psi_m, psi_n, psi_len_r_kj, psi_len_m, psi_len_n,\n"
"                forceBuffer[8 * index + 4], forceBuffer[8 * index + 5],\n"
"                forceBuffer[8 * index + 6], forceBuffer[8 * index + 7]);\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void computeGMMRest(\n"
"                            const real4* __restrict__ posq,             // positions and charges\n"
"                            const int numRestraints,                    // number of restraints\n"
"                            const int4* __restrict__ params,            // nPairs, nComponents, globalIndices\n"
"                            const int2* __restrict__ offsets,           // atomBlockOffset, dataBlockOffset\n"
"                            const int* __restrict__ atomIndices,        // atom indices\n"
"                            const float* __restrict__ data,             // weights, means, diags, offdiags\n"
"                            float* __restrict__ energies,               // global array of restraint energies\n"
"                            float3* __restrict__ forceBuffer) {         // temporary buffer to hold the force\n"
"    extern __shared__ volatile char scratch[];\n"
"\n"
"\n"
"    int tid = threadIdx.x;\n"
"    int warp = tid / 32;\n"
"    int lane = tid % 32;\n"
"\n"
"    float* distances = (float*)&scratch[0];\n"
"    float* probabilities = (float*)&scratch[16*32*sizeof(float)];\n"
"\n"
"    distances[tid] = 0.0;\n"
"    probabilities[tid] = 0.0;\n"
"\n"
"    for (int index=16*blockIdx.x + warp; index<numRestraints; index+=16*gridDim.x) {\n"
"        int nPairs = params[index].x;\n"
"        int nComponents = params[index].y;\n"
"        int globalIndex = params[index].z;\n"
"        float scale = (float)(params[index].w) * 1e-6;\n"
"\n"
"        int atomBlockOffset = offsets[index].x;\n"
"        int dataBlockOffset = offsets[index].y;\n"
"\n"
"        // compute my distance\n"
"        if (lane < nPairs) {\n"
"            int atomIndex1 = atomIndices[atomBlockOffset + 2 * lane];\n"
"            int atomIndex2 = atomIndices[atomBlockOffset + 2 * lane + 1];\n"
"\n"
"            real4 delta = posq[atomIndex1] - posq[atomIndex2];\n"
"            real distSquared = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"            real r = SQRT(distSquared);\n"
"            distances[tid] = r;\n"
"        }\n"
"        __syncthreads();\n"
"\n"
"\n"
"        float minsum = 9e99;\n"
"\n"
"        // compute my probability\n"
"        const int blockSize = 1 + 2*nPairs + nPairs*(nPairs-1)/2;\n"
"        if (lane < nComponents) {\n"
"            // compute offsets into data array\n"
"            const float weight = data[dataBlockOffset + lane*blockSize];\n"
"            const float* means = &data[dataBlockOffset + lane*blockSize + 1];\n"
"            const float* diags = &data[dataBlockOffset + lane*blockSize + nPairs + 1];\n"
"            const float* offdiags = &data[dataBlockOffset + lane*blockSize + 2*nPairs + 1];\n"
"            float sum = 0;\n"
"\n"
"            // do the diagonal part\n"
"            for (int i=0; i<nPairs; i++) {\n"
"                float mean = means[i];\n"
"                float diag = diags[i] * scale;\n"
"                float dist = distances[32 * warp + i];\n"
"                sum += (mean - dist) * (mean - dist) * diag;\n"
"            }\n"
"\n"
"            // do the off diagonal part\n"
"            int count = 0;\n"
"            for (int i=0; i<nPairs; i++) {\n"
"                for (int j=i+1; j<nPairs; j++) {\n"
"                    float meani = means[i];\n"
"                    float meanj = means[j];\n"
"                    float coeff = 2 * offdiags[count] * scale;\n"
"                    float disti = distances[32 * warp + i];\n"
"                    float distj = distances[32 * warp + j];\n"
"                    sum += (disti - meani) * (distj - meanj) * coeff;\n"
"                    count++;\n"
"                }\n"
"            }\n"
"            probabilities[tid] = sum;\n"
"\n"
"            __syncthreads();\n"
"\n"
"            for (int i=0; i<nComponents; i++) {\n"
"                if(probabilities[32 * warp + i] < minsum) {\n"
"                    minsum = probabilities[32 * warp + i];\n"
"                }\n"
"            }\n"
"            __syncthreads();\n"
"\n"
"            probabilities[tid] = weight * exp(-0.5 * (sum - minsum));\n"
"            __syncthreads();\n"
"        }\n"
"\n"
"        // compute and store forces\n"
"        float totalProb = 0;\n"
"        for (int i=0; i<nComponents; i++) {\n"
"            totalProb += probabilities[32 * warp + i];\n"
"        }\n"
"\n"
"        if (lane < nPairs) {\n"
"            float dEdr = 0;\n"
"\n"
"            // compute diagonal part of force\n"
"            for (int i=0; i<nComponents; i++) {\n"
"                float distance = distances[32 * warp + lane];\n"
"                float mean = data[dataBlockOffset + i*blockSize + lane + 1];\n"
"                float diag = data[dataBlockOffset + i*blockSize + nPairs + lane + 1];\n"
"                dEdr += 2.48 * probabilities[32 * warp + i] / totalProb * (distance - mean) * diag * scale;\n"
"            }\n"
"\n"
"            // compute off diagonal part of force\n"
"            for (int i=0; i<nComponents; i++) {\n"
"                for (int k=0; k<nPairs; k++) {\n"
"                    if (k != lane) {\n"
"                        float r = distances[32 * warp + k];\n"
"                        float mu = data[dataBlockOffset + i*blockSize + k + 1];\n"
"                        int coeffIndex = 0;\n"
"                        if (k > lane) {\n"
"                            coeffIndex = nPairs*(nPairs-1)/2 - (nPairs-lane)*((nPairs-lane)-1)/2 + k - lane - 1;\n"
"                        } else {\n"
"                            coeffIndex = nPairs*(nPairs-1)/2 - (nPairs-k)*((nPairs-k)-1)/2 + lane - k - 1;\n"
"                        }\n"
"                        float coeff = data[dataBlockOffset + i*blockSize + 1 + 2*nPairs + coeffIndex];\n"
"                        dEdr += 2.48 * probabilities[32 * warp + i] / totalProb * (r - mu) * coeff * scale;\n"
"                    }\n"
"                }\n"
"            }\n"
"            int atomIndex1 = atomIndices[atomBlockOffset + 2 * lane];\n"
"            int atomIndex2 = atomIndices[atomBlockOffset + 2 * lane + 1];\n"
"            real4 delta = posq[atomIndex1] - posq[atomIndex2];\n"
"            float4 f = dEdr * delta / distances[32 * warp + lane];\n"
"            forceBuffer[atomBlockOffset + lane].x = f.x;\n"
"            forceBuffer[atomBlockOffset + lane].y = f.y;\n"
"            forceBuffer[atomBlockOffset + lane].z = f.z;\n"
"        }\n"
"\n"
"        // compute and store the energy\n"
"        if (lane == 0) {\n"
"            float energy = -2.48 * (log(totalProb) - 0.5 * minsum);\n"
"            energies[globalIndex] = energy;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// extern \"C\" __global__ void computeGridPotentialRest(\n"
"//                             const real4* __restrict__ posq,\n"
"//                             const int* __restrict__ atomIndices, \n"
"//                             const float* __restrict__ potentials,\n"
"//                             const float* __restrict__ grid_x,\n"
"//                             const float* __restrict__ grid_y,\n"
"//                             const float* __restrict__ grid_z,\n"
"//                             const float* __restrict__ weights,\n"
"//                             const int* __restrict__ nxyz,\n"
"//                             const int* __restrict__ densityIndices,\n"
"//                             const int* __restrict__ indexToGlobal,\n"
"//                             const int numRestraints,\n"
"//                             float* __restrict__ energies,    \n"
"//                             float3* __restrict__ forceBuffer)\n"
"// {\n"
"//     for (int res=blockIdx.y*blockDim.y+threadIdx.y; res < numRestraints; res+=blockDim.y*gridDim.y) {\n"
"//         int globalIndex = indexToGlobal[res];\n"
"//         energies[globalIndex] = 0;\n"
"//         __syncthreads();\n"
"//     }\n"
"//     int grid_xmax = nxyz[0];\n"
"//     int grid_ymax = nxyz[1];\n"
"//     int grid_zmax = nxyz[2];\n"
"//     int grid_total = grid_xmax * grid_ymax * grid_zmax;\n"
"//     for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numRestraints; index+=blockDim.x*gridDim.x) {\n"
"//         int globalIndex = indexToGlobal[index];\n"
"//         int grids_index = densityIndices[index];\n"
"//         int atomIndex = atomIndices[index];\n"
"//         float atom_weight = weights[index];\n"
"//         float3 atom_pos = trimTo3(posq[atomIndex]);\n"
"//         // printf(\"grid_x[0]: %f \\n\", grid_x[0]);\n"
"//         // check the atom is in which grid\n"
"//         int grid_xnum = floor((atom_pos.x-grid_x[0])/(grid_x[1]-grid_x[0])) + 1; \n"
"//         int grid_ynum = floor((atom_pos.y-grid_y[0])/(grid_y[1]-grid_y[0])) + 1;\n"
"//         int grid_znum = floor((atom_pos.z-grid_z[0])/(grid_z[1]-grid_z[0])) + 1;\n"
"//         // scale atom position with grid length\n"
"//         float grid_x_pos = (grid_x[grid_xnum]-atom_pos.x)/(grid_x[1]-grid_x[0]); \n"
"//         float grid_y_pos = (grid_y[grid_ynum]-atom_pos.y)/(grid_y[1]-grid_y[0]);\n"
"//         float grid_z_pos = (grid_z[grid_znum]-atom_pos.z)/(grid_z[1]-grid_z[0]);\n"
"//         float grid_xpos = (atom_pos.x-grid_x[grid_xnum-1])/(grid_x[1]-grid_x[0]);\n"
"//         float grid_ypos = (atom_pos.y-grid_y[grid_ynum-1])/(grid_y[1]-grid_y[0]);\n"
"//         float grid_zpos = (atom_pos.z-grid_z[grid_znum-1])/(grid_z[1]-grid_z[0]);\n"
"//         float energy = 0;\n"
"//         float f_x = 0;\n"
"//         float f_y = 0;\n"
"//         float f_z = 0;        \n"
"//         float v_000 = potentials[grid_total*grids_index+(grid_znum-1) * grid_ymax * grid_xmax + (grid_ynum-1) * grid_xmax + grid_xnum -1];\n"
"//         float v_100 = potentials[grid_total*grids_index+(grid_znum-1) * grid_ymax * grid_xmax + (grid_ynum-1) * grid_xmax + grid_xnum];\n"
"//         float v_010 = potentials[grid_total*grids_index+(grid_znum-1) * grid_ymax * grid_xmax + grid_ynum * grid_xmax + grid_xnum -1];\n"
"//         float v_001 = potentials[grid_total*grids_index+grid_znum * grid_ymax * grid_xmax + (grid_ynum-1) * grid_xmax + grid_xnum -1];\n"
"//         float v_101 = potentials[grid_total*grids_index+grid_znum * grid_ymax * grid_xmax + (grid_ynum-1) * grid_xmax + grid_xnum];\n"
"//         float v_011 = potentials[grid_total*grids_index+grid_znum * grid_ymax * grid_xmax + grid_ynum * grid_xmax + grid_xnum -1];\n"
"//         float v_110 = potentials[grid_total*grids_index+(grid_znum-1) * grid_ymax * grid_xmax + grid_ynum * grid_xmax + grid_xnum ];\n"
"//         float v_111 = potentials[grid_total*grids_index+grid_znum * grid_ymax * grid_xmax + grid_ynum * grid_xmax + grid_xnum];\n"
"\n"
"//         energy  = atom_weight * (v_000 * grid_x_pos * grid_y_pos * grid_z_pos              \n"
"//                 + v_100 * grid_xpos * grid_y_pos * grid_z_pos \n"
"//                 + v_010 * grid_x_pos * grid_ypos * grid_z_pos   \n"
"//                 + v_001 * grid_x_pos * grid_y_pos * grid_zpos\n"
"//                 + v_101 * grid_xpos * grid_y_pos * grid_zpos \n"
"//                 + v_011 * grid_x_pos * grid_ypos * grid_zpos\n"
"//                 + v_110 * grid_xpos * grid_ypos * grid_z_pos           \n"
"//                 + v_111 * grid_xpos * grid_ypos * grid_zpos)  ;\n"
"\n"
"//         f_x += -1 * atom_weight * ((v_100 - v_000) * grid_y_pos * grid_z_pos \n"
"//                 + (v_110 - v_010) * grid_ypos * grid_z_pos\n"
"//                 + (v_101 - v_001) * grid_y_pos * grid_zpos\n"
"//                 + (v_111 - v_011) * grid_ypos * grid_zpos)/(grid_x[1]-grid_x[0])   ;\n"
"                \n"
"//         f_y += -1 * atom_weight * ((v_010 - v_000) * grid_x_pos * grid_z_pos \n"
"//                 + (v_110 - v_100) * grid_xpos * grid_z_pos\n"
"//                 + (v_011 - v_001) * grid_x_pos * grid_zpos\n"
"//                 + (v_111 - v_101) * grid_xpos * grid_zpos)/(grid_y[1]-grid_y[0])  ;\n"
"\n"
"//         f_z += -1 * atom_weight * ((v_001 - v_000) * grid_x_pos * grid_y_pos \n"
"//                 + (v_101 - v_100) * grid_xpos * grid_y_pos\n"
"//                 + (v_011 - v_010) * grid_x_pos * grid_ypos\n"
"//                 + (v_111 - v_110) * grid_xpos * grid_ypos)/(grid_z[1]-grid_z[0])   ;\n"
"\n"
"//         forceBuffer[index] = make_float3(f_x,f_y,f_z);\n"
"//         printf(\"pre energy: %f \\n\", energies[globalIndex]);\n"
"//         energies[globalIndex] = energy;\n"
"//         printf(\"post energy: %f, %f\\n\", energies[globalIndex], energy);\n"
"//         // printf(\"energy_now: %f\\n\", energy_now);\n"
"\n"
"//         if (index==0){\n"
"//             printf(\"gridx_0: %f, gridx_1: %f, v: %f,%f,%f,%f,%f,%f,%f,%f, atompos: %f,%f,%f, f_x,f_y,f_z: %f,%f,%f \\n\",grid_x[0],grid_x[1],v_000,v_100,v_010,v_001,v_101,v_011,v_110,v_111,atom_pos.x,atom_pos.y,atom_pos.z,f_x,f_y,f_z);\n"
"//         }\n"
"//         __syncthreads();\n"
"//     }\n"
"//     // __syncthreads();\n"
"// }\n"
"extern \"C\" __global__ void computeGridPotentialRest(\n"
"                            const real4* __restrict__ posq, \n"
"                            const int* __restrict__ atomIndices, \n"
"                            const float* __restrict__ grid_x,\n"
"                            const float* __restrict__ grid_y,\n"
"                            const float* __restrict__ grid_z,\n"
"                            const float* __restrict__ mu,\n"
"                            const float* __restrict__ emap_weights,\n"
"                            const int* __restrict__ emapAtomList, \n"
"                            int* __restrict__ indexToGlobal,\n"
"                            float* __restrict__ energies, \n"
"                            float3* __restrict__ forceBuffer,\n"
"                            const int numRestraints,\n"
"                            const int3 numEmapGrids,\n"
"                            const int numEmapAtoms) {\n"
"        // set all emap restraints to 0 in the beginning\n"
"        for (int res=blockIdx.y*blockDim.y+threadIdx.y; res < numRestraints; res+=blockDim.y*gridDim.y) {\n"
"            int globalIndex = indexToGlobal[res];\n"
"            energies[globalIndex] = 0;\n"
"            __syncthreads();\n"
"        }\n"
"        // calculate force for each atom in all atom sets\n"
"        for (int index=blockIdx.x*blockDim.x+threadIdx.x; index<numEmapAtoms; index+=blockDim.x*gridDim.x) {\n"
"            int index_global;\n"
"            int mu_index;\n"
"            // determine atom is in which atom sets, then get globalIndex for store energy later\n"
"            for (int atom_list=blockIdx.y*blockDim.y+threadIdx.y; atom_list < numRestraints; atom_list+=blockDim.y*gridDim.y) {\n"
"                const int globalIndex = indexToGlobal[atom_list];\n"
"                if ((index - emapAtomList[atom_list] >= 0) && (index - emapAtomList[atom_list+1] < 0)) {\n"
"                    index_global = globalIndex;\n"
"                    mu_index = atom_list;\n"
"                }\n"
"                __syncthreads();\n"
"            }\n"
"            int atomIndex = atomIndices[index];\n"
"            float emap_weight = emap_weights[index]; // mass of the atom\n"
"            float3 f = make_float3(0,0,0);\n"
"            float3 atom_pos = trimTo3(posq[atomIndex]);\n"
"            int grid_xmax = numEmapGrids.x;\n"
"            int grid_ymax = numEmapGrids.y;\n"
"            int grid_zmax = numEmapGrids.z;\n"
"            int mu_num = grid_xmax*grid_ymax*grid_zmax; // size of map dimension to determine the atom corresponds to which grid potential set (mu) \n"
"                                                        // if the input has multiple maps assuming all maps have the \n"
"                                                        // same dimension but the potential on each grid could be different.\n"
"                                                        // mu shape (1,num_maps*numEmapGrids.x*numEmapGrids.y*numEmapGrids.z)\n"
"            // check the atom is in which grid\n"
"            int grid_xnum = floor((atom_pos.x-grid_x[0])/(grid_x[1]-grid_x[0])) + 1; \n"
"            int grid_ynum = floor((atom_pos.y-grid_y[0])/(grid_y[1]-grid_y[0])) + 1;\n"
"            int grid_znum = floor((atom_pos.z-grid_z[0])/(grid_z[1]-grid_z[0])) + 1;\n"
"            // scale atom position with grid length\n"
"            float grid_x_pos = (grid_x[grid_xnum]-atom_pos.x)/(grid_x[1]-grid_x[0]); \n"
"            float grid_y_pos = (grid_y[grid_ynum]-atom_pos.y)/(grid_y[1]-grid_y[0]);\n"
"            float grid_z_pos = (grid_z[grid_znum]-atom_pos.z)/(grid_z[1]-grid_z[0]);\n"
"            float grid_xpos = (atom_pos.x-grid_x[grid_xnum-1])/(grid_x[1]-grid_x[0]);\n"
"            float grid_ypos = (atom_pos.y-grid_y[grid_ynum-1])/(grid_y[1]-grid_y[0]);\n"
"            float grid_zpos = (atom_pos.z-grid_z[grid_znum-1])/(grid_z[1]-grid_z[0]);\n"
"            float energy = 0;\n"
"            float f_x = 0;\n"
"            float f_y = 0;\n"
"            float f_z = 0;\n"
"            // linear interpolation\n"
"                // get potential at 8 grids around the atom\n"
"            float v_000 = mu[mu_num*mu_index+(grid_znum-1) * grid_ymax * grid_xmax + (grid_ynum-1) * grid_xmax + grid_xnum -1];\n"
"            float v_100 = mu[mu_num*mu_index+(grid_znum-1) * grid_ymax * grid_xmax + (grid_ynum-1) * grid_xmax + grid_xnum];\n"
"            float v_010 = mu[mu_num*mu_index+(grid_znum-1) * grid_ymax * grid_xmax + grid_ynum * grid_xmax + grid_xnum -1];\n"
"            float v_001 = mu[mu_num*mu_index+grid_znum * grid_ymax * grid_xmax + (grid_ynum-1) * grid_xmax + grid_xnum -1];\n"
"            float v_101 = mu[mu_num*mu_index+grid_znum * grid_ymax * grid_xmax + (grid_ynum-1) * grid_xmax + grid_xnum];\n"
"            float v_011 = mu[mu_num*mu_index+grid_znum * grid_ymax * grid_xmax + grid_ynum * grid_xmax + grid_xnum -1];\n"
"            float v_110 = mu[mu_num*mu_index+(grid_znum-1) * grid_ymax * grid_xmax + grid_ynum * grid_xmax + grid_xnum ];\n"
"            float v_111 = mu[mu_num*mu_index+grid_znum * grid_ymax * grid_xmax + grid_ynum * grid_xmax + grid_xnum];\n"
"            energy += emap_weight * (v_000 * grid_x_pos * grid_y_pos * grid_z_pos              \n"
"                    + v_100 * grid_xpos * grid_y_pos * grid_z_pos \n"
"                    + v_010 * grid_x_pos * grid_ypos * grid_z_pos   \n"
"                    + v_001 * grid_x_pos * grid_y_pos * grid_zpos\n"
"                    + v_101 * grid_xpos * grid_y_pos * grid_zpos \n"
"                    + v_011 * grid_x_pos * grid_ypos * grid_zpos\n"
"                    + v_110 * grid_xpos * grid_ypos * grid_z_pos           \n"
"                    + v_111 * grid_xpos * grid_ypos * grid_zpos)  ;\n"
"            // printf(\"grid_x[0]: %f \\n\", grid_x[0]);\n"
"            f_x += -1 * emap_weight * ((v_100 - v_000) * grid_y_pos * grid_z_pos \n"
"                    + (v_110 - v_010) * grid_ypos * grid_z_pos\n"
"                    + (v_101 - v_001) * grid_y_pos * grid_zpos\n"
"                    + (v_111 - v_011) * grid_ypos * grid_zpos)/(grid_x[1]-grid_x[0])   ;\n"
"                    \n"
"            f_y += -1 * emap_weight * ((v_010 - v_000) * grid_x_pos * grid_z_pos \n"
"                    + (v_110 - v_100) * grid_xpos * grid_z_pos\n"
"                    + (v_011 - v_001) * grid_x_pos * grid_zpos\n"
"                    + (v_111 - v_101) * grid_xpos * grid_zpos)/(grid_x[1]-grid_x[0])  ;\n"
"\n"
"            f_z += -1 * emap_weight * ((v_001 - v_000) * grid_x_pos * grid_y_pos \n"
"                    + (v_101 - v_100) * grid_xpos * grid_y_pos\n"
"                    + (v_011 - v_010) * grid_x_pos * grid_ypos\n"
"                    + (v_111 - v_110) * grid_xpos * grid_ypos)/(grid_x[1]-grid_x[0])   ;\n"
"            // if (index==140){\n"
"            //     printf(\"xyz: %d %f, %f, %f \\n\", index, atom_pos.x, atom_pos.y, atom_pos.z);\n"
"            // }\n"
"            forceBuffer[index] = make_float3(f_x,f_y,f_z);\n"
"            // printf(\"pre energy: %f \\n\",energies[index_global]);\n"
"            // printf(\"mu[49895]: %f \\n\",mu[49895]);\n"
"            energies[index_global] += energy;\n"
"            // printf(\"energy: %f, %f\\n\",energies[index_global], energy);\n"
"            __syncthreads();\n"
"        }\n"
"\n"
"}\n"
"\n"
"\n"
"\n"
"extern \"C\" __global__ void evaluateAndActivate(\n"
"        const int numGroups,\n"
"        const int* __restrict__ numActiveArray,\n"
"        const int2* __restrict__ boundsArray,\n"
"        const int* __restrict__ indexArray,\n"
"        const float* __restrict__ energyArray,\n"
"        float* __restrict__ activeArray,\n"
"        float* __restrict__ groupEnergyArray)\n"
"{\n"
"    // Setup type alias for collective operations\n"
"    typedef cub::BlockRadixSort<float, NGROUPTHREADS, RESTS_PER_THREAD> BlockRadixSortT;\n"
"    typedef cub::BlockReduce<float, NGROUPTHREADS> BlockReduceT;\n"
"\n"
"    // Setup shared memory for sorting.\n"
"    __shared__ union {\n"
"        typename BlockRadixSortT::TempStorage sort;\n"
"        typename BlockReduceT::TempStorage reduce;\n"
"        float cutoff;\n"
"    } sharedScratch;\n"
"\n"
"    // local storage for energies to be sorted\n"
"    float energyScratch[RESTS_PER_THREAD];\n"
"\n"
"    for (int groupIndex=blockIdx.x; groupIndex<numGroups; groupIndex+=gridDim.x) {\n"
"        int numActive = numActiveArray[groupIndex];\n"
"        int start = boundsArray[groupIndex].x;\n"
"        int end = boundsArray[groupIndex].y;\n"
"\n"
"        // Load energies into statically allocated scratch buffer\n"
"        for(int i=0; i<RESTS_PER_THREAD; i++) {\n"
"            int index = threadIdx.x * RESTS_PER_THREAD + start + i;\n"
"            if(index < end) {\n"
"                energyScratch[i] = energyArray[indexArray[index]];\n"
"            } else {\n"
"                energyScratch[i] = FLT_MAX;\n"
"            }\n"
"        }\n"
"        __syncthreads();\n"
"\n"
"        // Sort the energies.\n"
"        BlockRadixSortT(sharedScratch.sort).Sort(energyScratch);\n"
"        __syncthreads();\n"
"\n"
"        // find the nth largest energy and store in scratch\n"
"        int myMin = threadIdx.x * RESTS_PER_THREAD;\n"
"        int myMax = myMin + RESTS_PER_THREAD;\n"
"        if((numActive - 1) >= myMin) {\n"
"            if((numActive - 1) < myMax) {\n"
"                // only one thread will get here\n"
"                int offset = numActive - 1 - myMin;\n"
"                sharedScratch.cutoff = energyScratch[offset];\n"
"            }\n"
"        }\n"
"        __syncthreads();\n"
"\n"
"        // Read the nth largest energy from shared memory.\n"
"        float cutoff = (volatile float)sharedScratch.cutoff;\n"
"        __syncthreads();\n"
"\n"
"        // now we know the cutoff, so apply it to each group and\n"
"        // load each energy into a scratch buffer.\n"
"        for(int i=0; i<RESTS_PER_THREAD; i++) {\n"
"            int index = threadIdx.x * RESTS_PER_THREAD + start + i;\n"
"            if(index < end) {\n"
"                if (energyArray[indexArray[index]] <= cutoff) {\n"
"                    activeArray[indexArray[index]] = 1.0;\n"
"                    energyScratch[i] = energyArray[indexArray[index]];\n"
"\n"
"                } else {\n"
"                    activeArray[indexArray[index]] = 0.0;\n"
"                    energyScratch[i] = 0.0;\n"
"                }\n"
"            } else {\n"
"                energyScratch[i] = 0.0;\n"
"            }\n"
"        }\n"
"        __syncthreads();\n"
"\n"
"        // Now sum all of the energies to get the total energy\n"
"        // for the group.\n"
"        float totalEnergy = BlockReduceT(sharedScratch.reduce).Sum(energyScratch);\n"
"        if(threadIdx.x == 0) {\n"
"            groupEnergyArray[groupIndex] = totalEnergy;\n"
"        }\n"
"        __syncthreads();\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void evaluateAndActivateCollections(\n"
"        const int numCollections,\n"
"        const int* __restrict__ numActiveArray,\n"
"        const int2* __restrict__ boundsArray,\n"
"        const int* __restrict__ indexArray,\n"
"        const float* __restrict__ energyArray,\n"
"        float* __restrict__ activeArray)\n"
"{\n"
"    // Setup type alias for sorting.\n"
"    typedef cub::BlockRadixSort<float, NCOLLTHREADS, GROUPS_PER_THREAD> BlockRadixSortT;\n"
"\n"
"    // Setup shared memory for sorting.\n"
"    __shared__ union {\n"
"        typename BlockRadixSortT::TempStorage sort;\n"
"        float cutoff;\n"
"    } sharedScratch;\n"
"\n"
"    // local storage for energies to be sorted\n"
"    float energyScratch[GROUPS_PER_THREAD];\n"
"\n"
"    for (int collIndex=blockIdx.x; collIndex<numCollections; collIndex+=gridDim.x) {\n"
"        int numActive = numActiveArray[collIndex];\n"
"        int start = boundsArray[collIndex].x;\n"
"        int end = boundsArray[collIndex].y;\n"
"\n"
"        // Load energies into statically allocated scratch buffer\n"
"        for(int i=0; i<GROUPS_PER_THREAD; i++) {\n"
"            int index = threadIdx.x * GROUPS_PER_THREAD + start + i;\n"
"            if(index < end) {\n"
"                energyScratch[i] = energyArray[indexArray[index]];\n"
"            } else {\n"
"                energyScratch[i] = FLT_MAX;\n"
"            }\n"
"        }\n"
"        __syncthreads();\n"
"\n"
"        // Sort the energies.\n"
"        BlockRadixSortT(sharedScratch.sort).Sort(energyScratch);\n"
"        __syncthreads();\n"
"\n"
"        // find the nth largest energy and store in scratch\n"
"        int myMin = threadIdx.x * GROUPS_PER_THREAD;\n"
"        int myMax = myMin + GROUPS_PER_THREAD;\n"
"        if((numActive - 1) >= myMin) {\n"
"            if((numActive - 1) < myMax) {\n"
"                // only one thread will get here\n"
"                int offset = numActive - 1 - myMin;\n"
"                sharedScratch.cutoff = energyScratch[offset];\n"
"            }\n"
"        }\n"
"        __syncthreads();\n"
"\n"
"        // Read the nth largest energy from shared memory.\n"
"        float cutoff = (volatile float)sharedScratch.cutoff;\n"
"\n"
"        // now we know the cutoff, so apply it to each group\n"
"        for (int i=start + threadIdx.x; i<end; i+=blockDim.x) {\n"
"            if (energyArray[indexArray[i]] <= cutoff) {\n"
"                activeArray[indexArray[i]] = 1.0;\n"
"            }\n"
"            else {\n"
"                activeArray[indexArray[i]] = 0.0;\n"
"            }\n"
"        }\n"
"        __syncthreads();\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyGroups(\n"
"                            float* __restrict__ groupActive,\n"
"                            float* __restrict__ restraintActive,\n"
"                            const int2* __restrict__ bounds,\n"
"                            int numGroups) {\n"
"    for (int groupIndex=blockIdx.x; groupIndex<numGroups; groupIndex+=gridDim.x) {\n"
"        float active = groupActive[groupIndex];\n"
"        for (int i=bounds[groupIndex].x + threadIdx.x; i<bounds[groupIndex].y; i+=blockDim.x) {\n"
"            restraintActive[i] *= active;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyDistRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int2* __restrict__ atomIndices,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numDistRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numDistRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            int index1 = atomIndices[restraintIndex].x;\n"
"            int index2 = atomIndices[restraintIndex].y;\n"
"            if (index1 == -1) {\n"
"                // Do nothing. This restraint is marked as being\n"
"                // not mapped, so it contributes no energy or force.\n"
"            } else {\n"
"                energyAccum += globalEnergies[globalIndex];\n"
"                float3 f = restForces[restraintIndex];\n"
"\n"
"                atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (-f.x*0x100000000)));\n"
"                atomicAdd(&force[index1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.y*0x100000000)));\n"
"                atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.z*0x100000000)));\n"
"\n"
"                atomicAdd(&force[index2], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"                atomicAdd(&force[index2  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"                atomicAdd(&force[index2 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"            }\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyHyperbolicDistRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int2* __restrict__ atomIndices,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numDistRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numDistRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            int index1 = atomIndices[restraintIndex].x;\n"
"            int index2 = atomIndices[restraintIndex].y;\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"            float3 f = restForces[restraintIndex];\n"
"\n"
"            atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (-f.x*0x100000000)));\n"
"            atomicAdd(&force[index1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.y*0x100000000)));\n"
"            atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[index2], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"            atomicAdd(&force[index2  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"            atomicAdd(&force[index2 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyTorsionRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int4* __restrict__ atomIndices,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            int atom_i = atomIndices[restraintIndex].x;\n"
"            int atom_j = atomIndices[restraintIndex].y;\n"
"            int atom_k = atomIndices[restraintIndex].z;\n"
"            int atom_l = atomIndices[restraintIndex].w;\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"\n"
"            // update forces\n"
"            float3 f_i = restForces[restraintIndex * 4 + 0];\n"
"            float3 f_j = restForces[restraintIndex * 4 + 1];\n"
"            float3 f_k = restForces[restraintIndex * 4 + 2];\n"
"            float3 f_l = restForces[restraintIndex * 4 + 3];\n"
"\n"
"            atomicAdd(&force[atom_i],                        static_cast<unsigned long long>((long long) (f_i.x*0x100000000)));\n"
"            atomicAdd(&force[atom_i  + PADDED_NUM_ATOMS],    static_cast<unsigned long long>((long long) (f_i.y*0x100000000)));\n"
"            atomicAdd(&force[atom_i + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f_i.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[atom_j],                        static_cast<unsigned long long>((long long) (f_j.x*0x100000000)));\n"
"            atomicAdd(&force[atom_j  + PADDED_NUM_ATOMS],    static_cast<unsigned long long>((long long) (f_j.y*0x100000000)));\n"
"            atomicAdd(&force[atom_j + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f_j.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[atom_k],                        static_cast<unsigned long long>((long long) (f_k.x*0x100000000)));\n"
"            atomicAdd(&force[atom_k  + PADDED_NUM_ATOMS],    static_cast<unsigned long long>((long long) (f_k.y*0x100000000)));\n"
"            atomicAdd(&force[atom_k + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f_k.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[atom_l],                        static_cast<unsigned long long>((long long) (f_l.x*0x100000000)));\n"
"            atomicAdd(&force[atom_l  + PADDED_NUM_ATOMS],    static_cast<unsigned long long>((long long) (f_l.y*0x100000000)));\n"
"            atomicAdd(&force[atom_l + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f_l.z*0x100000000)));\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyDistProfileRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int2* __restrict__ atomIndices,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            int index1 = atomIndices[restraintIndex].x;\n"
"            int index2 = atomIndices[restraintIndex].y;\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"            float3 f = restForces[restraintIndex];\n"
"\n"
"            atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (-f.x*0x100000000)));\n"
"            atomicAdd(&force[index1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.y*0x100000000)));\n"
"            atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[index2], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"            atomicAdd(&force[index2  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"            atomicAdd(&force[index2 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"\n"
"extern \"C\" __global__ void applyTorsProfileRest(\n"
"                                unsigned long long * __restrict__ force,\n"
"                                mixed* __restrict__ energyBuffer,\n"
"                                const int4* __restrict__ atomIndices0,\n"
"                                const int4* __restrict__ atomIndices1,\n"
"                                const int* __restrict__ globalIndices,\n"
"                                const float3* __restrict__ restForces,\n"
"                                const float* __restrict__ globalEnergies,\n"
"                                const float* __restrict__ globalActive,\n"
"                                const int numRestraints) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            // update energy\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"\n"
"            // update phi\n"
"            int phi_atom_i = atomIndices0[restraintIndex].x;\n"
"            int phi_atom_j = atomIndices0[restraintIndex].y;\n"
"            int phi_atom_k = atomIndices0[restraintIndex].z;\n"
"            int phi_atom_l = atomIndices0[restraintIndex].w;\n"
"\n"
"            // update forces\n"
"            float3 phi_f_i = restForces[restraintIndex * 8 + 0];\n"
"            float3 phi_f_j = restForces[restraintIndex * 8 + 1];\n"
"            float3 phi_f_k = restForces[restraintIndex * 8 + 2];\n"
"            float3 phi_f_l = restForces[restraintIndex * 8 + 3];\n"
"\n"
"            atomicAdd(&force[phi_atom_i],                        static_cast<unsigned long long>((long long) (phi_f_i.x*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_i + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (phi_f_i.y*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_i + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (phi_f_i.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[phi_atom_j],                        static_cast<unsigned long long>((long long) (phi_f_j.x*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_j + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (phi_f_j.y*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_j + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (phi_f_j.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[phi_atom_k],                        static_cast<unsigned long long>((long long) (phi_f_k.x*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_k + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (phi_f_k.y*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_k + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (phi_f_k.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[phi_atom_l],                        static_cast<unsigned long long>((long long) (phi_f_l.x*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_l + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (phi_f_l.y*0x100000000)));\n"
"            atomicAdd(&force[phi_atom_l + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (phi_f_l.z*0x100000000)));\n"
"\n"
"            // update psi\n"
"            int psi_atom_i = atomIndices1[restraintIndex].x;\n"
"            int psi_atom_j = atomIndices1[restraintIndex].y;\n"
"            int psi_atom_k = atomIndices1[restraintIndex].z;\n"
"            int psi_atom_l = atomIndices1[restraintIndex].w;\n"
"\n"
"            // update forces\n"
"            float3 psi_f_i = restForces[restraintIndex * 8 + 4];\n"
"            float3 psi_f_j = restForces[restraintIndex * 8 + 5];\n"
"            float3 psi_f_k = restForces[restraintIndex * 8 + 6];\n"
"            float3 psi_f_l = restForces[restraintIndex * 8 + 7];\n"
"\n"
"            atomicAdd(&force[psi_atom_i],                        static_cast<unsigned long long>((long long) (psi_f_i.x*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_i + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (psi_f_i.y*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_i + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (psi_f_i.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[psi_atom_j],                        static_cast<unsigned long long>((long long) (psi_f_j.x*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_j + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (psi_f_j.y*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_j + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (psi_f_j.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[psi_atom_k],                        static_cast<unsigned long long>((long long) (psi_f_k.x*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_k + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (psi_f_k.y*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_k + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (psi_f_k.z*0x100000000)));\n"
"\n"
"            atomicAdd(&force[psi_atom_l],                        static_cast<unsigned long long>((long long) (psi_f_l.x*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_l + PADDED_NUM_ATOMS],     static_cast<unsigned long long>((long long) (psi_f_l.y*0x100000000)));\n"
"            atomicAdd(&force[psi_atom_l + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (psi_f_l.z*0x100000000)));\n"
"        }\n"
"    }\n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"extern \"C\" __global__ void applyGMMRest(unsigned long long * __restrict__ force,\n"
"                                        mixed* __restrict__ energyBuffer,\n"
"                                        const int numRestraints,\n"
"                                        const int4* __restrict params,\n"
"                                        const float* __restrict__ globalEnergies,\n"
"                                        const float* __restrict__ globalActive,\n"
"                                        const int2* __restrict__ offsets,\n"
"                                        const int* __restrict__ atomIndices,\n"
"                                        const float3* __restrict__ restForces) {\n"
"\n"
"    int tid = threadIdx.x;\n"
"    int warp = tid / 32;\n"
"    int lane = tid % 32;\n"
"\n"
"    for (int index=16*blockIdx.x + warp; index<numRestraints; index+=16*gridDim.x) {\n"
"        int nPairs = params[index].x;\n"
"        int globalIndex = params[index].z;\n"
"        int atomBlockOffset = offsets[index].x;\n"
"\n"
"        if (globalActive[globalIndex]) {\n"
"            // add the forces\n"
"            if (lane < nPairs) {\n"
"                float3 f = restForces[atomBlockOffset + lane];\n"
"                int atomIndex1 = atomIndices[atomBlockOffset + 2 * lane];\n"
"                int atomIndex2 = atomIndices[atomBlockOffset + 2 * lane + 1];\n"
"\n"
"                atomicAdd(&force[atomIndex1], static_cast<unsigned long long>((long long) (-f.x*0x100000000)));\n"
"                atomicAdd(&force[atomIndex1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.y*0x100000000)));\n"
"                atomicAdd(&force[atomIndex1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.z*0x100000000)));\n"
"\n"
"                atomicAdd(&force[atomIndex2], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"                atomicAdd(&force[atomIndex2  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"                atomicAdd(&force[atomIndex2 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"            }\n"
"\n"
"            // add the energy\n"
"            if (lane == 0) {\n"
"                energyBuffer[tid] += globalEnergies[globalIndex];\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"\n"
"    // int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    // float energyAccum = 0.0;\n"
"\n"
"    // for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numDistRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"    //     int globalIndex = globalIndices[restraintIndex];\n"
"    //     if (globalActive[globalIndex]) {\n"
"    //         int index1 = atomIndices[restraintIndex].x;\n"
"    //         int index2 = atomIndices[restraintIndex].y;\n"
"    //         energyAccum += globalEnergies[globalIndex];\n"
"    //         float3 f = restForces[restraintIndex];\n"
"\n"
"    //         atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (-f.x*0x100000000)));\n"
"    //         atomicAdd(&force[index1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.y*0x100000000)));\n"
"    //         atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (-f.z*0x100000000)));\n"
"\n"
"    //         atomicAdd(&force[index2], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"    //         atomicAdd(&force[index2  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"    //         atomicAdd(&force[index2 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"    //     }\n"
"    // }\n"
"    // energyBuffer[threadIndex] += energyAccum;\n"
"}\n"
"\n"
"// extern \"C\" __global__ void applyGridPotentialRest(unsigned long long * __restrict__ force,\n"
"//                                          mixed* __restrict__ energyBuffer,\n"
"//                                          const int* __restrict__ atomIndices,\n"
"//                                          const int* __restrict__ globalIndices,\n"
"//                                          const float* __restrict__ globalEnergies,\n"
"//                                          const float* __restrict__ globalActive,\n"
"//                                          const float3* __restrict__ restForces,\n"
"//                                          const int numRestraints) {\n"
"//     int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"//     float energyAccum = 0.0;\n"
"//     for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"//         int globalIndex = globalIndices[restraintIndex];\n"
"//         printf(\"globalEnergies[%d]: %f \\n\",globalIndex,globalEnergies[globalIndex]);\n"
"//         if (globalActive[globalIndex]) {\n"
"//             int index1 = atomIndices[restraintIndex];\n"
"//             energyAccum += globalEnergies[globalIndex];\n"
"//             float3 f = restForces[restraintIndex];\n"
"//             atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"//             atomicAdd(&force[index1 + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"//             atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"//             printf(\"f_xyz: %d %f, %f, %f \\n\", index1, f.x, f.y, f.z);\n"
"//         }\n"
"//         __syncthreads();\n"
"//     }\n"
"//     // __syncthreads();\n"
"//     printf(\"energyBuffer: %f \\n\",energyBuffer[threadIndex]);\n"
"//     energyBuffer[threadIndex] += energyAccum;\n"
"//     printf(\"energyAccum: %f, %f \\n\",energyBuffer[threadIndex],energyAccum);\n"
"// }\n"
"extern \"C\" __global__ void applyGridPotentialRest(unsigned long long * __restrict__ force,\n"
"                                         mixed* __restrict__ energyBuffer,\n"
"                                         const int* __restrict__ atomIndices,\n"
"                                         const int* __restrict__ emapAtomList, \n"
"                                         const int* __restrict__ globalIndices,\n"
"                                         const float* __restrict__ globalEnergies,\n"
"                                         const float* __restrict__ globalActive,\n"
"                                         const float3* __restrict__ restForces,\n"
"                                         const int numEmapRestraints,\n"
"                                         const int numEmapAtoms) {\n"
"    int threadIndex = blockIdx.x * blockDim.x + threadIdx.x;\n"
"    float energyAccum = 0.0;\n"
"    // add force to each atom if the restraint it belongs to is active\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numEmapAtoms; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int index1 = atomIndices[restraintIndex];\n"
"        float3 f = restForces[restraintIndex];\n"
"        for (int atom_list=blockIdx.y*blockDim.y+threadIdx.y; atom_list < numEmapRestraints; atom_list+=blockDim.y*gridDim.y) {\n"
"            const int globalIndex = globalIndices[atom_list];\n"
"            //printf(\"globalIndex: %d \\n\",globalActive[globalIndex]);\n"
"            if ((restraintIndex - emapAtomList[atom_list] >= 0) && (restraintIndex - emapAtomList[atom_list+1] < 0) && (globalActive[globalIndex])) {\n"
"                atomicAdd(&force[index1], static_cast<unsigned long long>((long long) (f.x*0x100000000)));\n"
"                atomicAdd(&force[index1  + PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.y*0x100000000)));\n"
"                atomicAdd(&force[index1 + 2 * PADDED_NUM_ATOMS], static_cast<unsigned long long>((long long) (f.z*0x100000000)));\n"
"                // printf(\"f_xyz: %d %f, %f, %f \\n\", index1, f.x, f.y, f.z);\n"
"            }\n"
"            if (restraintIndex==140){\n"
"                // printf(\"f_xyz: %d,%d, %f, %f, %f \\n\", restraintIndex,index1, f.x, f.y, f.z);\n"
"            }\n"
"        }\n"
"    }\n"
"    for (int restraintIndex=blockIdx.x*blockDim.x+threadIdx.x; restraintIndex<numEmapRestraints; restraintIndex+=blockDim.x*gridDim.x) {\n"
"        int globalIndex = globalIndices[restraintIndex];\n"
"        if (globalActive[globalIndex]) {\n"
"            energyAccum += globalEnergies[globalIndex];\n"
"        }\n"
"    }\n"
"    // printf(\"energyBuffer: %f \\n\",energyBuffer[threadIndex]);    \n"
"    energyBuffer[threadIndex] += energyAccum;\n"
"    float3 f = restForces[threadIndex];\n"
"    // printf(\"energyBuffer,energyAccum: %f, %f \\n\",energyBuffer[threadIndex],energyAccum);\n"
"}";
const string CudaMeldKernelSources::vectorOps = "/**\n"
" * This file defines vector operations to simplify code elsewhere.\n"
"*/\n"
"\n"
"// Versions of make_x() that take a single value and set all components to that.\n"
"\n"
"inline __device__ int2 make_int2(int a) {\n"
"    return make_int2(a, a);\n"
"}\n"
"\n"
"inline __device__ int3 make_int3(int a) {\n"
"    return make_int3(a, a, a);\n"
"}\n"
"\n"
"inline __device__ int4 make_int4(int a) {\n"
"    return make_int4(a, a, a, a);\n"
"}\n"
"\n"
"inline __device__ float2 make_float2(float a) {\n"
"    return make_float2(a, a);\n"
"}\n"
"\n"
"inline __device__ float3 make_float3(float a) {\n"
"    return make_float3(a, a, a);\n"
"}\n"
"\n"
"inline __device__ float4 make_float4(float a) {\n"
"    return make_float4(a, a, a, a);\n"
"}\n"
"\n"
"inline __device__ double2 make_double2(double a) {\n"
"    return make_double2(a, a);\n"
"}\n"
"\n"
"inline __device__ double3 make_double3(double a) {\n"
"    return make_double3(a, a, a);\n"
"}\n"
"\n"
"inline __device__ double4 make_double4(double a) {\n"
"    return make_double4(a, a, a, a);\n"
"}\n"
"\n"
"// Negate a vector.\n"
"\n"
"inline __device__ int2 operator-(int2 a) {\n"
"    return make_int2(-a.x, -a.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator-(int3 a) {\n"
"    return make_int3(-a.x, -a.y, -a.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator-(int4 a) {\n"
"    return make_int4(-a.x, -a.y, -a.z, -a.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator-(float2 a) {\n"
"    return make_float2(-a.x, -a.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator-(float3 a) {\n"
"    return make_float3(-a.x, -a.y, -a.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator-(float4 a) {\n"
"    return make_float4(-a.x, -a.y, -a.z, -a.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator-(double2 a) {\n"
"    return make_double2(-a.x, -a.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator-(double3 a) {\n"
"    return make_double3(-a.x, -a.y, -a.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator-(double4 a) {\n"
"    return make_double4(-a.x, -a.y, -a.z, -a.w);\n"
"}\n"
"\n"
"// Add two vectors.\n"
"\n"
"inline __device__ int2 operator+(int2 a, int2 b) {\n"
"    return make_int2(a.x+b.x, a.y+b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator+(int3 a, int3 b) {\n"
"    return make_int3(a.x+b.x, a.y+b.y, a.z+b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator+(int4 a, int4 b) {\n"
"    return make_int4(a.x+b.x, a.y+b.y, a.z+b.z, a.w+b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator+(float2 a, float2 b) {\n"
"    return make_float2(a.x+b.x, a.y+b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator+(float3 a, float3 b) {\n"
"    return make_float3(a.x+b.x, a.y+b.y, a.z+b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator+(float4 a, float4 b) {\n"
"    return make_float4(a.x+b.x, a.y+b.y, a.z+b.z, a.w+b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator+(double2 a, double2 b) {\n"
"    return make_double2(a.x+b.x, a.y+b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator+(double3 a, double3 b) {\n"
"    return make_double3(a.x+b.x, a.y+b.y, a.z+b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator+(double4 a, double4 b) {\n"
"    return make_double4(a.x+b.x, a.y+b.y, a.z+b.z, a.w+b.w);\n"
"}\n"
"\n"
"// Subtract two vectors.\n"
"\n"
"inline __device__ int2 operator-(int2 a, int2 b) {\n"
"    return make_int2(a.x-b.x, a.y-b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator-(int3 a, int3 b) {\n"
"    return make_int3(a.x-b.x, a.y-b.y, a.z-b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator-(int4 a, int4 b) {\n"
"    return make_int4(a.x-b.x, a.y-b.y, a.z-b.z, a.w-b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator-(float2 a, float2 b) {\n"
"    return make_float2(a.x-b.x, a.y-b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator-(float3 a, float3 b) {\n"
"    return make_float3(a.x-b.x, a.y-b.y, a.z-b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator-(float4 a, float4 b) {\n"
"    return make_float4(a.x-b.x, a.y-b.y, a.z-b.z, a.w-b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator-(double2 a, double2 b) {\n"
"    return make_double2(a.x-b.x, a.y-b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator-(double3 a, double3 b) {\n"
"    return make_double3(a.x-b.x, a.y-b.y, a.z-b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator-(double4 a, double4 b) {\n"
"    return make_double4(a.x-b.x, a.y-b.y, a.z-b.z, a.w-b.w);\n"
"}\n"
"\n"
"// Multiply two vectors.\n"
"\n"
"inline __device__ int2 operator*(int2 a, int2 b) {\n"
"    return make_int2(a.x*b.x, a.y*b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator*(int3 a, int3 b) {\n"
"    return make_int3(a.x*b.x, a.y*b.y, a.z*b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator*(int4 a, int4 b) {\n"
"    return make_int4(a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator*(float2 a, float2 b) {\n"
"    return make_float2(a.x*b.x, a.y*b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator*(float3 a, float3 b) {\n"
"    return make_float3(a.x*b.x, a.y*b.y, a.z*b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator*(float4 a, float4 b) {\n"
"    return make_float4(a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator*(double2 a, double2 b) {\n"
"    return make_double2(a.x*b.x, a.y*b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator*(double3 a, double3 b) {\n"
"    return make_double3(a.x*b.x, a.y*b.y, a.z*b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator*(double4 a, double4 b) {\n"
"    return make_double4(a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w);\n"
"}\n"
"\n"
"// Divide two vectors.\n"
"\n"
"inline __device__ int2 operator/(int2 a, int2 b) {\n"
"    return make_int2(a.x/b.x, a.y/b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator/(int3 a, int3 b) {\n"
"    return make_int3(a.x/b.x, a.y/b.y, a.z/b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator/(int4 a, int4 b) {\n"
"    return make_int4(a.x/b.x, a.y/b.y, a.z/b.z, a.w/b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator/(float2 a, float2 b) {\n"
"    return make_float2(a.x/b.x, a.y/b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator/(float3 a, float3 b) {\n"
"    return make_float3(a.x/b.x, a.y/b.y, a.z/b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator/(float4 a, float4 b) {\n"
"    return make_float4(a.x/b.x, a.y/b.y, a.z/b.z, a.w/b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator/(double2 a, double2 b) {\n"
"    return make_double2(a.x/b.x, a.y/b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator/(double3 a, double3 b) {\n"
"    return make_double3(a.x/b.x, a.y/b.y, a.z/b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator/(double4 a, double4 b) {\n"
"    return make_double4(a.x/b.x, a.y/b.y, a.z/b.z, a.w/b.w);\n"
"}\n"
"\n"
"// += operator\n"
"\n"
"inline __device__ void operator+=(int2& a, int2 b) {\n"
"    a.x += b.x; a.y += b.y;\n"
"}\n"
"\n"
"inline __device__ void operator+=(int3& a, int3 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z;\n"
"}\n"
"\n"
"inline __device__ void operator+=(int4& a, int4 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z; a.w += b.w;\n"
"}\n"
"\n"
"inline __device__ void operator+=(float2& a, float2 b) {\n"
"    a.x += b.x; a.y += b.y;\n"
"}\n"
"\n"
"inline __device__ void operator+=(float3& a, float3 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z;\n"
"}\n"
"\n"
"inline __device__ void operator+=(float4& a, float4 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z; a.w += b.w;\n"
"}\n"
"\n"
"inline __device__ void operator+=(double2& a, double2 b) {\n"
"    a.x += b.x; a.y += b.y;\n"
"}\n"
"\n"
"inline __device__ void operator+=(double3& a, double3 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z;\n"
"}\n"
"\n"
"inline __device__ void operator+=(double4& a, double4 b) {\n"
"    a.x += b.x; a.y += b.y; a.z += b.z; a.w += b.w;\n"
"}\n"
"\n"
"// -= operator\n"
"\n"
"inline __device__ void operator-=(int2& a, int2 b) {\n"
"    a.x -= b.x; a.y -= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator-=(int3& a, int3 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator-=(int4& a, int4 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z; a.w -= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator-=(float2& a, float2 b) {\n"
"    a.x -= b.x; a.y -= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator-=(float3& a, float3 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator-=(float4& a, float4 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z; a.w -= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator-=(double2& a, double2 b) {\n"
"    a.x -= b.x; a.y -= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator-=(double3& a, double3 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator-=(double4& a, double4 b) {\n"
"    a.x -= b.x; a.y -= b.y; a.z -= b.z; a.w -= b.w;\n"
"}\n"
"\n"
"// *= operator\n"
"\n"
"inline __device__ void operator*=(int2& a, int2 b) {\n"
"    a.x *= b.x; a.y *= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator*=(int3& a, int3 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator*=(int4& a, int4 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z; a.w *= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float2& a, float2 b) {\n"
"    a.x *= b.x; a.y *= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float3& a, float3 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float4& a, float4 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z; a.w *= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double2& a, double2 b) {\n"
"    a.x *= b.x; a.y *= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double3& a, double3 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double4& a, double4 b) {\n"
"    a.x *= b.x; a.y *= b.y; a.z *= b.z; a.w *= b.w;\n"
"}\n"
"\n"
"// /= operator\n"
"\n"
"inline __device__ void operator/=(int2& a, int2 b) {\n"
"    a.x /= b.x; a.y /= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator/=(int3& a, int3 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator/=(int4& a, int4 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z; a.w /= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator/=(float2& a, float2 b) {\n"
"    a.x /= b.x; a.y /= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator/=(float3& a, float3 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator/=(float4& a, float4 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z; a.w /= b.w;\n"
"}\n"
"\n"
"inline __device__ void operator/=(double2& a, double2 b) {\n"
"    a.x /= b.x; a.y /= b.y;\n"
"}\n"
"\n"
"inline __device__ void operator/=(double3& a, double3 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z;\n"
"}\n"
"\n"
"inline __device__ void operator/=(double4& a, double4 b) {\n"
"    a.x /= b.x; a.y /= b.y; a.z /= b.z; a.w /= b.w;\n"
"}\n"
"\n"
"// Multiply a vector by a constant.\n"
"\n"
"inline __device__ int2 operator*(int2 a, int b) {\n"
"    return make_int2(a.x*b, a.y*b);\n"
"}\n"
"\n"
"inline __device__ int3 operator*(int3 a, int b) {\n"
"    return make_int3(a.x*b, a.y*b, a.z*b);\n"
"}\n"
"\n"
"inline __device__ int4 operator*(int4 a, int b) {\n"
"    return make_int4(a.x*b, a.y*b, a.z*b, a.w*b);\n"
"}\n"
"\n"
"inline __device__ int2 operator*(int a, int2 b) {\n"
"    return make_int2(a*b.x, a*b.y);\n"
"}\n"
"\n"
"inline __device__ int3 operator*(int a, int3 b) {\n"
"    return make_int3(a*b.x, a*b.y, a*b.z);\n"
"}\n"
"\n"
"inline __device__ int4 operator*(int a, int4 b) {\n"
"    return make_int4(a*b.x, a*b.y, a*b.z, a*b.w);\n"
"}\n"
"\n"
"inline __device__ float2 operator*(float2 a, float b) {\n"
"    return make_float2(a.x*b, a.y*b);\n"
"}\n"
"\n"
"inline __device__ float3 operator*(float3 a, float b) {\n"
"    return make_float3(a.x*b, a.y*b, a.z*b);\n"
"}\n"
"\n"
"inline __device__ float4 operator*(float4 a, float b) {\n"
"    return make_float4(a.x*b, a.y*b, a.z*b, a.w*b);\n"
"}\n"
"\n"
"inline __device__ float2 operator*(float a, float2 b) {\n"
"    return make_float2(a*b.x, a*b.y);\n"
"}\n"
"\n"
"inline __device__ float3 operator*(float a, float3 b) {\n"
"    return make_float3(a*b.x, a*b.y, a*b.z);\n"
"}\n"
"\n"
"inline __device__ float4 operator*(float a, float4 b) {\n"
"    return make_float4(a*b.x, a*b.y, a*b.z, a*b.w);\n"
"}\n"
"\n"
"inline __device__ double2 operator*(double2 a, double b) {\n"
"    return make_double2(a.x*b, a.y*b);\n"
"}\n"
"\n"
"inline __device__ double3 operator*(double3 a, double b) {\n"
"    return make_double3(a.x*b, a.y*b, a.z*b);\n"
"}\n"
"\n"
"inline __device__ double4 operator*(double4 a, double b) {\n"
"    return make_double4(a.x*b, a.y*b, a.z*b, a.w*b);\n"
"}\n"
"\n"
"inline __device__ double2 operator*(double a, double2 b) {\n"
"    return make_double2(a*b.x, a*b.y);\n"
"}\n"
"\n"
"inline __device__ double3 operator*(double a, double3 b) {\n"
"    return make_double3(a*b.x, a*b.y, a*b.z);\n"
"}\n"
"\n"
"inline __device__ double4 operator*(double a, double4 b) {\n"
"    return make_double4(a*b.x, a*b.y, a*b.z, a*b.w);\n"
"}\n"
"\n"
"// Divide a vector by a constant.\n"
"\n"
"inline __device__ int2 operator/(int2 a, int b) {\n"
"    return make_int2(a.x/b, a.y/b);\n"
"}\n"
"\n"
"inline __device__ int3 operator/(int3 a, int b) {\n"
"    return make_int3(a.x/b, a.y/b, a.z/b);\n"
"}\n"
"\n"
"inline __device__ int4 operator/(int4 a, int b) {\n"
"    return make_int4(a.x/b, a.y/b, a.z/b, a.w/b);\n"
"}\n"
"\n"
"inline __device__ float2 operator/(float2 a, float b) {\n"
"    float scale = 1.0f/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ float3 operator/(float3 a, float b) {\n"
"    float scale = 1.0f/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ float4 operator/(float4 a, float b) {\n"
"    float scale = 1.0f/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ double2 operator/(double2 a, double b) {\n"
"    double scale = 1.0/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ double3 operator/(double3 a, double b) {\n"
"    double scale = 1.0/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"inline __device__ double4 operator/(double4 a, double b) {\n"
"    double scale = 1.0/b;\n"
"    return a*scale;\n"
"}\n"
"\n"
"// *= operator (multiply vector by constant)\n"
"\n"
"inline __device__ void operator*=(int2& a, int b) {\n"
"    a.x *= b; a.y *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(int3& a, int b) {\n"
"    a.x *= b; a.y *= b; a.z *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(int4& a, int b) {\n"
"    a.x *= b; a.y *= b; a.z *= b; a.w *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float2& a, float b) {\n"
"    a.x *= b; a.y *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float3& a, float b) {\n"
"    a.x *= b; a.y *= b; a.z *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(float4& a, float b) {\n"
"    a.x *= b; a.y *= b; a.z *= b; a.w *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double2& a, double b) {\n"
"    a.x *= b; a.y *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double3& a, double b) {\n"
"    a.x *= b; a.y *= b; a.z *= b;\n"
"}\n"
"\n"
"inline __device__ void operator*=(double4& a, double b) {\n"
"    a.x *= b; a.y *= b; a.z *= b; a.w *= b;\n"
"}\n"
"\n"
"// Dot product\n"
"\n"
"inline __device__ float dot(float3 a, float3 b) {\n"
"    return a.x*b.x+a.y*b.y+a.z*b.z;\n"
"}\n"
"\n"
"inline __device__ double dot(double3 a, double3 b) {\n"
"    return a.x*b.x+a.y*b.y+a.z*b.z;\n"
"}\n"
"\n"
"// Cross product\n"
"\n"
"inline __device__ float3 cross(float3 a, float3 b) {\n"
"    return make_float3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n"
"}\n"
"\n"
"inline __device__ float3 cross(float4 a, float4 b) {\n"
"    return make_float3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n"
"}\n"
"\n"
"inline __device__ double3 cross(double3 a, double3 b) {\n"
"    return make_double3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n"
"}\n"
"\n"
"inline __device__ double3 cross(double4 a, double4 b) {\n"
"    return make_double3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n"
"}\n"
"\n"
"// Normalize a vector\n"
"\n"
"inline __device__ float2 normalize(float2 a) {\n"
"    return a*rsqrtf(a.x*a.x+a.y*a.y);\n"
"}\n"
"\n"
"inline __device__ float3 normalize(float3 a) {\n"
"    return a*rsqrtf(a.x*a.x+a.y*a.y+a.z*a.z);\n"
"}\n"
"\n"
"inline __device__ float4 normalize(float4 a) {\n"
"    return a*rsqrtf(a.x*a.x+a.y*a.y+a.z*a.z+a.w*a.w);\n"
"}\n"
"\n"
"inline __device__ double2 normalize(double2 a) {\n"
"    return a*rsqrt(a.x*a.x+a.y*a.y);\n"
"}\n"
"\n"
"inline __device__ double3 normalize(double3 a) {\n"
"    return a*rsqrt(a.x*a.x+a.y*a.y+a.z*a.z);\n"
"}\n"
"\n"
"inline __device__ double4 normalize(double4 a) {\n"
"    return a*rsqrt(a.x*a.x+a.y*a.y+a.z*a.z+a.w*a.w);\n"
"}\n"
"\n"
"// Strip off the fourth component of a vector.\n"
"\n"
"inline __device__ float3 trimTo3(float4 v) {\n"
"    return make_float3(v.x, v.y, v.z);\n"
"}\n"
"\n"
"inline __device__ double3 trimTo3(double4 v) {\n"
"    return make_double3(v.x, v.y, v.z);\n"
"}\n"
"";
